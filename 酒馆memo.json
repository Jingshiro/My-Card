{
  "id": "fe1e49e1-8e25-455d-9f9b-8cd0bff6e169",
  "name": "酒馆Memo",
  "content": "const STYLE_ID = 'memo-styles';\nconst MODAL_ID = 'memoModal';\nconst MODAL_CLASS_NAME = 'memo-modal-dialog';\nconst MODAL_CONTENT_CLASS = 'memo-modal-content';\nconst MODAL_HEADER_CLASS = 'memo-modal-header';\nconst MODAL_TITLE_CLASS = 'memo-modal-title';\nconst MODAL_CLOSE_X_CLASS = 'memo-modal-close-x';\nconst MODAL_BODY_CLASS = 'memo-modal-body';\nconst MODAL_FOOTER_CLASS = 'memo-modal-footer';\nconst MENU_BUTTON_ID = 'memoMenuButton';\nconst MEMO_INPUT_ID = 'memoInput';\nconst MEMO_TITLE_INPUT_ID = 'memoTitleInput';\nconst LOCAL_STORAGE_KEY_PREFIX = 'memo_'; // 前缀，后面跟角色-聊天记录标识\nconst GITHUB_CONFIG_KEY = 'memo_github_config'; // GitHub配置存储键\nconst STYLE_PREFERENCE_KEY = 'memo_style_preference'; // 样式偏好存储键\nconst FONT_STORAGE_KEY = 'memo_custom_fonts'; // 自定义字体存储键\nconst FONT_PREFERENCE_KEY = 'memo_font_preference'; // 字体偏好存储键\nconst CUSTOM_COLOR_CONFIG_KEY = 'memo_custom_color_config'; // 自定义颜色配置存储键\nconst LLM_CONFIG_KEY = 'memo_llm_config'; // LLM配置存储键\n\n\nlet MemoDoc = document;\nif (window.parent && window.parent.document && window.parent.document !== document) {\n  MemoDoc = window.parent.document;\n}\n\nlet modalElement = null;\nlet modalDialogElement = null;\nlet modalTitleElement = null;\nlet modalBodyElement = null;\nlet modalFooterElement = null;\nlet currentChatContext = null;\nlet chatChangeListener = null;\nlet messageObserver = null;\n\n// 多选模式状态管理\nconst selectionState = {\n  isMultiSelectMode: false,        // 是否在多选模式\n  selectedParagraphs: [],          // 已选段落数组 [{element, text, index, messageId}]\n  controlPanel: null               // 控制面板元素\n};\n\nconst state = {\n  memos: {},\n  currentView: 'list',\n  editingMemoId: null,\n  currentSourceContext: null,  // 当前源上下文信息（用于楼层信息）\n  sortBy: 'time',  // 排序方式：'time' | 'floor'\n  sortOrder: 'desc',  // 排序顺序：'asc' | 'desc'\n  selectedChatContext: null,  // 用户手动选择的聊天上下文\n  githubConfig: {\n    repo: '',      // 仓库地址，格式：username/repo\n    token: '',     // GitHub个人访问令牌\n    branch: 'main', // 分支名称\n    path: 'memo-data', // 保存数据的文件夹路径\n    filename: '',  // 自定义文件名\n    lastSync: null  // 上次同步时间\n  },\n  llmConfig: {\n    apiUrl: '',    // LLM API地址\n    apiKey: '',    // API密钥\n    model: '',     // 选择的模型\n    temperature: 0.7, // 温度参数\n    availableModels: [], // 可用模型列表\n    lastTest: null // 上次测试时间\n  },\n  fontConfig: {\n    customFonts: [],  // 自定义字体列表\n    currentFont: 'QiushuiShotai',  // 当前使用的字体\n    loadedFonts: new Set()  // 已加载的字体集合\n  },\n  customColorConfig: {\n    color1: '#f8f9ff',  // 渐变起始颜色（左上）\n    color2: '#fff5f0',  // 渐变结束颜色（右下）\n    fontColor: '#333333',  // 统一字体颜色\n    textColors: {       // 文本颜色配置\n      userInfo: '#666',\n      time: '#999',\n      title: '#2c3e50',\n      accent: '#4a9eff',\n      excerpt: '#34495e',\n      notes: '#555',\n      brand: '#999',\n      decorativeLine: '#4a9eff',\n      separatorLine: '#e0e0e0'\n    }\n  },\n  // 使用报告相关状态\n  currentReportText: '',     // 当前使用报告文本\n  currentReportImageUrl: ''  // 当前使用报告长图URL\n};\n\n\nfunction getMemoStyles() {\n  return `\n        @keyframes memoFadeIn {\n            from { opacity: 0; transform: translateY(-20px) scale(0.95); }\n            to { opacity: 1; transform: translateY(0) scale(1); }\n        }\n\n        @keyframes memoItemSlideIn {\n            from { opacity: 0; transform: translateX(-10px); }\n            to { opacity: 1; transform: translateX(0); }\n        }\n\n        #${MODAL_ID} {\n            display: none; \n            position: fixed;\n            z-index: 10000;\n            left: 0;\n            top: 0;\n            width: 100%;\n            height: 100%;\n            background-color: rgba(0, 0, 0, 0.5);\n            backdrop-filter: blur(5px);\n        }\n\n        .${MODAL_CLASS_NAME} {\n            background: var(--SmartThemeBlurTintColor, #1a1a1c);\n            color: var(--SmartThemeBodyColor, #e0e0e0);\n            border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n            border-radius: 12px;\n            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3), 0 8px 16px rgba(0, 0, 0, 0.2);\n            width: 750px;\n            max-width: 95vw;\n            max-height: 85vh;\n            animation: memoFadeIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);\n            display: flex;\n            flex-direction: column;\n            overflow: hidden;\n            position: fixed;\n            z-index: 10001;\n            box-sizing: border-box;\n        }\n\n        .${MODAL_HEADER_CLASS} {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            padding: 6px 20px 5px 20px;\n            border-bottom: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n            flex-shrink: 0;\n            background: linear-gradient(135deg, var(--SmartThemeQuoteColor, #4a9eff) 0%, transparent 100%);\n            background-size: 100% 2px;\n            background-repeat: no-repeat;\n            background-position: bottom;\n        }\n\n        .${MODAL_TITLE_CLASS} {\n            margin: 0;\n            font-weight: 600;\n            font-size: 16px;\n            color: var(--SmartThemeBodyColor, #ffffff);\n            letter-spacing: 0.5px;\n        }\n\n        .${MODAL_CLOSE_X_CLASS} {\n            background: transparent;\n            border: none;\n            color: var(--SmartThemeBodyColor, #aaa);\n            font-size: 24px;\n            font-weight: 300;\n            cursor: pointer;\n            padding: 8px;\n            line-height: 1;\n            transition: all 0.2s ease;\n            border-radius: 6px;\n            width: 40px;\n            height: 40px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n        .${MODAL_CLOSE_X_CLASS}:hover {\n            color: var(--SmartThemeBodyColor, #fff);\n            background: rgba(255, 255, 255, 0.1);\n            transform: scale(1.1);\n        }\n\n        .${MODAL_BODY_CLASS} {\n            padding: 24px;\n            overflow-y: auto;\n            flex-grow: 1;\n            text-align: left;\n            box-sizing: border-box;\n            min-height: 0;\n        }\n\n        .${MODAL_FOOTER_CLASS} {\n            padding: 10px 24px 14px 24px;\n            border-top: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n            display: flex;\n            justify-content: center;\n            gap: 12px;\n            flex-shrink: 0;\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.02));\n        }\n\n        .memo-button {\n            background: var(--SmartThemeQuoteColor, #4a9eff);\n            color: var(--SmartThemeBodyColor, #ffffff);\n            padding: 6px 16px;\n            border: none;\n            border-radius: 8px;\n            cursor: pointer;\n            font-size: 14px;\n            font-weight: 500;\n            transition: all 0.2s ease;\n            box-shadow: 0 2px 8px rgba(74, 158, 255, 0.2);\n            letter-spacing: 0.3px;\n        }\n        .memo-button:hover {\n            background: var(--SmartThemeQuoteColor, #3d8bff);\n            transform: translateY(-1px);\n            box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);\n        }\n        .memo-button:active {\n            transform: translateY(0);\n        }\n        .memo-button.danger {\n            background:rgb(240, 75, 89);\n            box-shadow: 0 2px 8px rgba(255, 71, 87, 0.2);\n        }\n        .memo-button.danger:hover {\n            background:rgb(240, 75, 89);\n            box-shadow: 0 4px 12px rgba(255, 71, 87, 0.3);\n        }\n        .memo-button.primary {\n            background: var(--SmartThemeQuoteColor, #4a9eff);\n            box-shadow: 0 2px 8px rgba(74, 158, 255, 0.2);\n        }\n        .memo-button.primary:hover {\n            background: var(--SmartThemeQuoteColor, #3d8bff);\n            box-shadow: 0 4px 12px rgba(74, 158, 255, 0.3);\n        }\n        .memo-button.secondary {\n            background: var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n            color: var(--SmartThemeBodyColor, #e0e0e0);\n            box-shadow: none;\n        }\n        .memo-button.secondary:hover {\n            background: rgba(255, 255, 255, 0.15);\n            box-shadow: 0 2px 8px rgba(255, 255, 255, 0.1);\n        }\n\n        .memo-list-container {\n            max-height: 450px;\n            overflow-y: auto;\n            margin-top: 16px;\n            padding-right: 4px;\n        }\n\n        .memo-list-container::-webkit-scrollbar {\n            width: 6px;\n        }\n\n        .memo-list-container::-webkit-scrollbar-track {\n            background: transparent;\n        }\n\n        .memo-list-container::-webkit-scrollbar-thumb {\n            background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.3));\n            border-radius: 3px;\n        }\n\n        .memo-list-container::-webkit-scrollbar-thumb:hover {\n            background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.5));\n        }\n\n        .memo-item {\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n            border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n            border-radius: 12px;\n            padding: 6px 8px;\n            margin-bottom: 4px;\n            transition: all 0.3s ease;\n            animation: memoItemSlideIn 0.3s ease-out;\n            position: relative;\n            overflow: hidden;\n            cursor: pointer;\n        }\n\n        .memo-item::before {\n            content: '';\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 4px;\n            height: 100%;\n            background: var(--SmartThemeQuoteColor, #4a9eff);\n            opacity: 0;\n            transition: opacity 0.3s ease;\n        }\n\n        .memo-item:hover {\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.08));\n            border-color: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.3));\n            transform: translateY(-2px);\n            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);\n        }\n\n        .memo-item:hover::before {\n            opacity: 1;\n        }\n\n        .memo-item:active {\n            transform: translateY(0);\n        }\n\n        .memo-item-header {\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            margin-bottom: 1px;\n            gap: 8px;\n        }\n\n        .memo-item-title {\n            font-weight: 600;\n            font-size: 14px;\n            color: var(--SmartThemeBodyColor, #ffffff);\n            margin: 0;\n            line-height: 1.3;\n            flex: 1;\n        }\n\n        .memo-item-date {\n            font-size: 10px;\n            color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.6));\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n            padding: 3px 6px;\n            border-radius: 4px;\n            white-space: nowrap;\n            font-weight: 500;\n        }\n\n        .memo-item-content {\n            color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.85));\n            line-height: 1.4;\n            margin-bottom: 3px;\n            font-size: 12px;\n            white-space: pre-line;\n            word-wrap: break-word;\n            word-break: break-word;\n        }\n\n        .memo-item-actions {\n            display: flex;\n            gap: 8px;\n            justify-content: flex-end;\n            margin-top: 2px;\n        }\n\n        .memo-action-button {\n            background: var(--SmartThemeQuoteColor, #4a9eff);\n            color: var(--SmartThemeBodyColor, #ffffff);\n            border: none;\n            padding: 4px 8px;\n            font-size: 11px;\n            border-radius: 4px;\n            cursor: pointer;\n            transition: all 0.2s ease;\n            font-weight: 500;\n            box-shadow: 0 2px 6px rgba(74, 158, 255, 0.2);\n        }\n        .memo-action-button:hover {\n            background: var(--SmartThemeQuoteColor, #3d8bff);\n            transform: translateY(-1px);\n            box-shadow: 0 4px 10px rgba(74, 158, 255, 0.3);\n        }\n        .memo-action-button.delete {\n            background:rgb(240, 75, 89);\n            color: var(--SmartThemeBodyColor, #ffffff);\n            border: none;\n            box-shadow: 0 2px 6px rgba(255, 71, 87, 0.2);\n        }\n        .memo-action-button.delete:hover {\n            background:rgb(240, 75, 89);\n            box-shadow: 0 4px 10px rgba(255, 71, 87, 0.3);\n        }\n        .memo-action-button.primary {\n            background: var(--SmartThemeQuoteColor, #4a9eff);\n            color: var(--SmartThemeBodyColor, #ffffff);\n            box-shadow: 0 2px 6px rgba(74, 158, 255, 0.2);\n        }\n        .memo-action-button.primary:hover {\n            background: var(--SmartThemeQuoteColor, #3d8bff);\n            box-shadow: 0 4px 10px rgba(74, 158, 255, 0.3);\n        }\n\n        .memo-form {\n            display: flex;\n            flex-direction: column;\n            gap: 20px;\n            margin-top: 10px;\n        }\n\n        .memo-form-group {\n            display: flex;\n            flex-direction: column;\n            gap: 8px;\n        }\n\n        .memo-form-label {\n            font-weight: 600;\n            color: var(--SmartThemeBodyColor, #ffffff);\n            font-size: 14px;\n            letter-spacing: 0.3px;\n        }\n\n        #${MEMO_TITLE_INPUT_ID} {\n            padding: 12px 16px;\n            border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n            border-radius: 10px;\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n            color: var(--SmartThemeBodyColor, #ffffff);\n            font-size: 14px;\n            transition: all 0.3s ease;\n            font-weight: 500;\n        }\n\n        #${MEMO_TITLE_INPUT_ID}:focus {\n            outline: none;\n            border-color: var(--SmartThemeQuoteColor, #4a9eff);\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.08));\n            box-shadow: 0 0 0 3px var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2));\n        }\n\n        #${MEMO_INPUT_ID} {\n            padding: 12px 16px;\n            border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n            border-radius: 10px;\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n            color: var(--SmartThemeBodyColor, #ffffff);\n            min-height: 140px;\n            resize: vertical;\n            font-family: inherit;\n            font-size: 14px;\n            line-height: 1.6;\n            transition: all 0.3s ease;\n        }\n\n        #${MEMO_INPUT_ID}:focus {\n            outline: none;\n            border-color: var(--SmartThemeQuoteColor, #4a9eff);\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.08));\n            box-shadow: 0 0 0 3px var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2));\n        }\n\n        .memo-chat-info {\n            background: linear-gradient(135deg, var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.1)) 0%, var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05)) 100%);\n            border: 1px solid var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2));\n            padding: 10px 16px;\n            border-radius: 12px;\n            margin-bottom: 12px;\n            font-size: 14px;\n            color: var(--SmartThemeBodyColor, #ffffff);\n            text-align: center;\n            font-weight: 500;\n            letter-spacing: 0.3px;\n            cursor: pointer;\n            position: relative;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            transition: all 0.2s ease;\n            z-index: 9990;\n        }\n        \n        .memo-chat-info:hover {\n            background: linear-gradient(135deg, var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.15)) 0%, var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.08)) 100%);\n            border-color: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.3));\n            transform: translateY(-1px);\n            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);\n            z-index: 9990;\n        }\n        \n        .memo-chat-info:after {\n            content: \"▼\";\n            font-size: 10px;\n            margin-left: 8px;\n            opacity: 0.7;\n            transition: transform 0.3s ease;\n        }\n        \n        .memo-chat-info.active:after {\n            transform: rotate(180deg);\n        }\n        \n        .memo-chat-dropdown {\n            position: absolute;\n            top: 100%;\n            left: 0;\n            right: 0;\n            background: var(--SmartThemeBlurTintColor, rgba(30, 30, 32, 0.95));\n            border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n            border-radius: 8px;\n            margin-top: 5px;\n            max-height: 0;\n            overflow: hidden;\n            opacity: 0;\n            transition: all 0.3s ease;\n            z-index: 10002;\n            backdrop-filter: blur(10px);\n            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);\n        }\n        \n        .memo-chat-dropdown.show {\n            max-height: 300px;\n            opacity: 1;\n            overflow-y: auto;\n        }\n        \n        /* 确保下拉菜单在显示时的z-index更高 */\n        #memoChatSelector.active {\n            z-index: 10002;\n        }\n        \n        #memoChatSelector.active .memo-chat-dropdown {\n            z-index: 10002;\n        }\n        \n        .memo-chat-dropdown-item {\n            padding: 8px 16px;\n            border-bottom: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.05));\n            cursor: pointer;\n            font-size: 13px;\n            color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8));\n            transition: all 0.2s ease;\n            display: flex;\n            align-items: center;\n            justify-content: space-between;\n        }\n        \n        .memo-chat-dropdown-item:hover {\n            background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.1));\n        }\n        \n        .memo-chat-dropdown-item.active {\n            background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2));\n            color: var(--SmartThemeBodyColor, #ffffff);\n            font-weight: 600;\n        }\n        \n        .memo-chat-dropdown-item-count {\n            background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2));\n            color: var(--SmartThemeBodyColor, #ffffff);\n            border-radius: 10px;\n            padding: 2px 6px;\n            font-size: 10px;\n            font-weight: 600;\n            min-width: 20px;\n            text-align: center;\n        }\n        \n        /* 调整筛选控制器的z-index */\n        .memo-filter-container {\n            position: relative;\n            z-index: 9980;\n        }\n        \n        /* 确保筛选按钮不会覆盖下拉菜单 */\n        .memo-filter-buttons {\n            position: relative;\n            z-index: 9980;\n        }\n\n        .memo-filter-btn {\n            position: relative;\n            z-index: 9980;\n        }\n        \n        .memo-order-btn {\n            position: relative;\n            z-index: 9980;\n        }\n\n        .empty-memo-message {\n            text-align: center;\n            color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.6));\n            padding: 60px 20px;\n            font-style: italic;\n            font-size: 16px;\n        }\n\n        .empty-memo-message p:first-child {\n            font-size: 18px;\n            margin-bottom: 8px;\n            color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8));\n        }\n\n        /* 响应式设计 */\n        @media (max-width: 768px) {\n            .${MODAL_CLASS_NAME} {\n                width: 95vw;\n                max-height: 90vh;\n                border-radius: 12px;\n            }\n            .${MODAL_BODY_CLASS} {\n                padding: 16px 12px;\n            }\n            .${MODAL_FOOTER_CLASS} {\n                padding: 10px 16px 14px 16px;\n                flex-direction: column;\n                gap: 8px;\n            }\n            .memo-button {\n                width: 100%;\n                justify-content: center;\n            }\n            .memo-item {\n                padding: 6px 8px;\n            }\n            .memo-item-header {\n                display: flex;\n                justify-content: space-between;\n                align-items: center;\n                gap: 8px;\n                margin-bottom: 1px;\n            }\n            .memo-item-title {\n                font-size: 13px;\n            }\n            .memo-item-date {\n                align-self: flex-end;\n            }\n            .memo-item-content {\n                margin-bottom: 3px;\n                font-size: 11px;\n            }\n            .memo-item-actions {\n                justify-content: center;\n                gap: 8px;\n                margin-top: 2px;\n            }\n            .memo-action-button {\n                flex: 1;\n                text-align: center;\n                padding: 3px 6px;\n                font-size: 10px;\n            }\n            \n            /* 确保筛选控制器在小屏幕也保持水平布局 */\n            .memo-filter-container {\n                flex-wrap: nowrap !important;\n            }\n        }\n\n        /* 段落注释按钮样式 */\n        .memo-annotation-btn {\n            position: absolute;\n            top: -10px;\n            right: -2px;\n            width: 18px;\n            height: 18px;\n            border: none;\n            border-radius: 3px;\n            background: transparent;\n            color: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.6));\n            font-size: 12px;\n            font-weight: bold;\n            cursor: pointer;\n            opacity: 0;\n            transition: all 0.2s ease;\n            z-index: 100;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            box-shadow: none;\n            line-height: 1;\n            user-select: none;\n            -webkit-user-select: none;\n            -moz-user-select: none;\n            -ms-user-select: none;\n        }\n\n        .memo-annotation-btn:hover {\n            background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.1));\n            color: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 1));\n            transform: scale(1.2);\n            box-shadow: 0 2px 8px rgba(74, 158, 255, 0.3);\n        }\n\n        .memo-annotation-btn:active {\n            background: transparent;\n            color: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 1));\n            transform: scale(1.1);\n            box-shadow: none;\n        }\n\n        .mes_text p:hover .memo-annotation-btn,\n        .message_text p:hover .memo-annotation-btn,\n        .mes_text div:hover .memo-annotation-btn {\n            opacity: 1;\n        }\n\n        .mes_text p {\n            position: relative;\n        }\n\n        .message_text p {\n            position: relative;\n        }\n\n        .mes_text div {\n            position: relative;\n        }\n\n        /* 移动端适配 */\n        @media (max-width: 768px) {\n            .memo-annotation-btn {\n                opacity: 0.7;\n                width: 20px;\n                height: 20px;\n                font-size: 12px;\n                right: 8px;\n            }\n        }\n\n        /* 多选控制面板样式 */\n        .memo-control-panel {\n            position: fixed !important;\n            bottom: 100px !important;\n            left: 50% !important;\n            width: 220px !important;\n            margin-left: -110px !important;\n            transform: none !important;\n            z-index: 9999 !important;\n            display: flex !important;\n            gap: 6px;\n            background: var(--SmartThemeBlurTintColor, rgba(0, 0, 0, 0.4)) !important;\n            padding: 6px 10px;\n            border-radius: 12px;\n            border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.15));\n            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);\n            backdrop-filter: blur(16px);\n            min-height: 40px;\n            visibility: visible !important;\n            opacity: 1 !important;\n            pointer-events: auto !important;\n            animation: none !important;\n            transition: none !important;\n            top: auto !important;\n        }\n\n        .memo-control-btn {\n            background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.7));\n            color: var(--SmartThemeBodyColor, #ffffff);\n            border: 1px solid var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.4));\n            padding: 4px 10px;\n            font-size: 12px;\n            border-radius: 6px;\n            cursor: pointer;\n            font-weight: 500;\n            white-space: nowrap;\n            box-shadow: 0 2px 8px rgba(74, 158, 255, 0.15);\n            backdrop-filter: blur(8px);\n            transition: none !important;\n            animation: none !important;\n        }\n\n        .memo-control-btn.secondary {\n            background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.3));\n            color: var(--SmartThemeBodyColor, #ffffff);\n            border: 1px solid var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.5));\n            box-shadow: 0 2px 8px rgba(74, 158, 255, 0.1);\n        }\n\n        .memo-control-btn:disabled {\n            background: rgba(255, 255, 255, 0.05);\n            color: rgba(255, 255, 255, 0.4);\n            border-color: rgba(255, 255, 255, 0.1);\n            cursor: not-allowed;\n            box-shadow: none;\n        }\n\n        /* 多选模式下的段落样式 */\n        .memo-multi-select-mode .memo-annotation-btn {\n            font-size: 14px;\n            width: 20px;\n            height: 20px;\n            border: 2px solid var(--SmartThemeQuoteColor, #4a9eff);\n            border-radius: 4px;\n            background: transparent;\n            color: var(--SmartThemeQuoteColor, #4a9eff);\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n\n        .memo-multi-select-mode .memo-annotation-btn.selected {\n            background: var(--SmartThemeQuoteColor, #4a9eff);\n            color: var(--SmartThemeBodyColor, #ffffff);\n        }\n\n        /* 选中段落的背景高亮 */\n        .memo-paragraph-selected {\n            border: 2px solid var(--SmartThemeQuoteColor, #4a9eff) !important;\n            border-radius: 6px !important;\n            padding: 4px !important;\n            margin: 2px 0 !important;\n            transition: all 0.2s ease !important;\n            box-shadow: 0 0 8px var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.3)) !important;\n        }\n\n        /* 样式选择器美化 */\n        #memoStyleSelector {\n            appearance: none;\n            -webkit-appearance: none;\n            -moz-appearance: none;\n            background-image: url(\"data:image/svg+xml;charset=UTF-8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6,9 12,15 18,9'></polyline></svg>\");\n            background-repeat: no-repeat;\n            background-position: right 8px center;\n            background-size: 16px;\n            padding-right: 32px !important;\n        }\n\n        #memoStyleSelector:focus {\n            outline: none;\n            border-color: var(--SmartThemeQuoteColor, #4a9eff) !important;\n            background-color: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.08)) !important;\n            box-shadow: 0 0 0 3px var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2)) !important;\n        }\n\n        #memoStyleSelector option {\n            background: var(--SmartThemeBlurTintColor, #2a2a2a);\n            color: var(--SmartThemeBodyColor, #ffffff);\n            padding: 8px;\n        }\n\n        /* 图片预览容器样式 */\n        #imagePreviewContainer {\n            transition: all 0.3s ease;\n        }\n\n        #imagePreviewContainer:hover {\n            border-color: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.3)) !important;\n        }\n\n        /* 加载指示器动画 */\n        #imageLoadingIndicator {\n            animation: memoLoadingPulse 1.5s ease-in-out infinite;\n        }\n\n        @keyframes memoLoadingPulse {\n            0%, 100% { opacity: 0.7; }\n            50% { opacity: 1; }\n        }\n\n        /* 筛选控制器样式 */\n        .memo-filter-container {\n            transition: all 0.3s ease;\n        }\n\n        .memo-filter-container:hover {\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05)) !important;\n            border-color: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2)) !important;\n        }\n\n        .memo-filter-buttons {\n            display: flex;\n            gap: 2px;\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n            padding: 2px;\n            border-radius: 6px;\n            border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n        }\n\n        .memo-filter-btn {\n            background: transparent;\n            color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7));\n            border: none;\n            padding: 3px 8px;\n            font-size: 11px;\n            border-radius: 4px;\n            cursor: pointer;\n            transition: all 0.2s ease;\n            font-weight: 500;\n            position: relative;\n            overflow: hidden;\n            white-space: nowrap;\n        }\n\n        .memo-filter-btn:hover {\n            color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.9));\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.1));\n        }\n\n        .memo-filter-btn.active {\n            background: var(--SmartThemeQuoteColor, #4a9eff);\n            color: var(--SmartThemeBodyColor, #ffffff);\n            box-shadow: 0 2px 8px var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.3));\n        }\n\n        .memo-filter-btn.active:hover {\n            background: var(--SmartThemeQuoteColor, #3d8bff);\n            color: var(--SmartThemeBodyColor, #ffffff);\n        }\n\n        .memo-order-btn {\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n            color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7));\n            border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n            padding: 4px 6px;\n            font-size: 12px;\n            border-radius: 5px;\n            cursor: pointer;\n            transition: all 0.2s ease;\n            font-weight: 600;\n            min-width: 24px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        }\n\n        .memo-order-btn:hover {\n            color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.9));\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.1));\n            border-color: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.3));\n            transform: translateY(-1px);\n        }\n\n        .memo-order-btn.active {\n            background: var(--SmartThemeQuoteColor, #4a9eff);\n            color: var(--SmartThemeBodyColor, #ffffff);\n            border-color: var(--SmartThemeQuoteColor, #4a9eff);\n            box-shadow: 0 2px 8px var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.3));\n        }\n\n        .memo-order-btn.active:hover {\n            background: var(--SmartThemeQuoteColor, #3d8bff);\n            border-color: var(--SmartThemeQuoteColor, #3d8bff);\n            transform: translateY(-1px);\n        }\n        \n        /* GitHub设置按钮样式 */\n        #memoSettingsBtn {\n            display: inline-block;\n            background: transparent;\n            border: none;\n            color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8));\n            font-size: 18px;\n            cursor: pointer;\n            margin-left: 4px;\n            transition: all 0.2s ease;\n            position: relative;\n            top: 0px;\n            line-height: 1;\n        }\n        \n        #memoSettingsBtn:hover {\n            color: var(--SmartThemeQuoteColor, #4a9eff);\n            transform: rotate(30deg);\n        }\n\n        .memo-copy-button {\n            position: absolute;\n            top: 8px;\n            right: 8px;\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.1));\n            color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7));\n            border: none;\n            padding: 4px;\n            font-size: 12px;\n            border-radius: 4px;\n            cursor: pointer;\n            transition: all 0.2s ease;\n            width: 24px;\n            height: 24px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n            opacity: 0.7;\n            z-index: 10002;\n        }\n        \n        .memo-textarea-container:hover .memo-copy-button {\n            opacity: 1;\n            background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2));\n        }\n        \n        .memo-copy-button:hover {\n            background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.3)) !important;\n            color: var(--SmartThemeBodyColor, #ffffff);\n            transform: scale(1.1);\n        }\n        \n        .memo-copy-button:active {\n            transform: scale(0.95);\n        }\n        \n        /* 确保textarea相对于container定位 */\n        .memo-textarea-container textarea {\n            width: 100%;\n            box-sizing: border-box;\n            position: relative;\n        }\n        \n        /* 修复Font Awesome图标 */\n        .memo-copy-button i {\n            font-size: 14px;\n            line-height: 1;\n        }\n\n        .memo-textarea-container {\n            position: relative;\n            width: 100%;\n        }\n    `;\n}\n\n\nfunction getCurrentChatContext() {\n  try {\n    // 获取当前聊天的实际名称\n    const chatName = getCurrentChatName();\n    const characterName = getCharacterName();\n\n    // 使用 角色名-聊天名 作为上下文\n    const context = `${characterName}-${chatName}`;\n    return context;\n  } catch (e) {\n    return 'default_chat';\n  }\n}\n\nfunction getCurrentChatName() {\n  try {\n    // 方法1: 从聊天文件名获取\n    if (window.chat_metadata && window.chat_metadata.filename) {\n      const filename = window.chat_metadata.filename.replace(/\\.(jsonl?|txt)$/i, '');\n      if (filename && filename !== 'undefined') {\n        return filename;\n      }\n    }\n\n    // 方法2: 从全局变量获取\n    if (window.selected_button && window.selected_button !== 'undefined') {\n      return window.selected_button;\n    }\n\n    // 方法3: 从DOM元素获取聊天标题\n    const chatTitleSelectors = [\n      '#chat_filename',\n      '.chat-title',\n      '.selected_chat',\n      '[data-chat-name]',\n      '.chat_select option:checked',\n      '#selected_chat_pole'\n    ];\n\n    for (const selector of chatTitleSelectors) {\n      const element = MemoDoc.querySelector(selector);\n      if (element) {\n        const chatName = element.textContent?.trim() || element.value?.trim() || element.getAttribute('data-chat-name');\n        if (chatName && chatName !== 'undefined' && chatName !== '') {\n          return chatName;\n        }\n      }\n    }\n\n    // 方法4: 从URL参数获取\n    const urlParams = new URLSearchParams(window.location.search);\n    if (urlParams.get('chat')) {\n      return urlParams.get('chat');\n    }\n\n    // 默认聊天名\n    return 'default_chat';\n  } catch (e) {\n    return 'default_chat';\n  }\n}\n\nfunction getCharacterName() {\n  try {\n    // 方法1: 使用 TavernHelper\n    if (window.TavernHelper && window.TavernHelper.getCharData) {\n      try {\n        const charData = window.TavernHelper.getCharData();\n        if (charData && charData.name) {\n          return charData.name;\n        }\n      } catch (e) {\n        // TavernHelper调用失败，继续使用其他方法\n      }\n    }\n\n    // 方法2: 从全局变量获取\n    if (window.name2 && window.name2 !== 'undefined') {\n      return window.name2;\n    }\n\n    // 方法3: 从DOM获取\n    const characterNameElement = MemoDoc.querySelector('#character_name_pole, .character_name, [data-character-name]');\n    if (characterNameElement) {\n      const charName = characterNameElement.textContent?.trim() || characterNameElement.getAttribute('data-character-name');\n      if (charName && charName !== 'undefined') {\n        return charName;\n      }\n    }\n\n    // 方法4: 从URL参数获取\n    const urlParams = new URLSearchParams(window.location.search);\n    if (urlParams.get('character')) {\n      return urlParams.get('character');\n    }\n\n    return 'unknown_character';\n  } catch (e) {\n    return 'unknown_character';\n  }\n}\n\nfunction getStorageKey(context) {\n  return `${LOCAL_STORAGE_KEY_PREFIX}${context}`;\n}\n\nfunction saveMemosToStorage(context, memos) {\n  try {\n    const key = getStorageKey(context);\n    localStorage.setItem(key, JSON.stringify(memos));\n  } catch (e) {\n    console.error('Memo: 保存Memo失败:', e);\n    toastr.error('保存失败: ' + e.message);\n  }\n}\n\nfunction loadMemosFromStorage(context) {\n  try {\n    const key = getStorageKey(context);\n    const stored = localStorage.getItem(key);\n    if (stored) {\n      return JSON.parse(stored);\n    }\n    return [];\n  } catch (e) {\n    console.error('Memo: 加载Memo失败:', e);\n    return [];\n  }\n}\n\n\nfunction injectStyles() {\n  if (!MemoDoc.getElementById(STYLE_ID)) {\n    const style = MemoDoc.createElement('style');\n    style.id = STYLE_ID;\n    style.textContent = getMemoStyles();\n    MemoDoc.head.appendChild(style);\n  }\n}\n\nfunction ensureModalStructure() {\n  if (!modalElement) {\n    modalElement = MemoDoc.createElement('div');\n    modalElement.id = MODAL_ID;\n    modalElement.innerHTML = `\n            <div class=\"${MODAL_CLASS_NAME}\">\n                <div class=\"${MODAL_HEADER_CLASS}\">\n                    <h3 class=\"${MODAL_TITLE_CLASS}\">Memo管理</h3>\n                    <div style=\"display: flex; align-items: center;\">\n                        <button id=\"memoClearAllBtn\" class=\"memo-clear-all-btn\" title=\"清除所有Memo\" style=\"\n                            background: transparent;\n                            border: none;\n                            color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7));\n                            font-size: 16px;\n                            cursor: pointer;\n                            padding: 8px;\n                            margin-right: 5px;\n                            display: flex;\n                            align-items: center;\n                            justify-content: center;\n                            transition: all 0.2s ease;\n                        \"><i class=\"fas fa-broom\"></i></button>\n                        <button class=\"${MODAL_CLOSE_X_CLASS}\">&times;</button>\n                    </div>\n                </div>\n                <div class=\"${MODAL_BODY_CLASS}\"></div>\n                <div class=\"${MODAL_FOOTER_CLASS}\"></div>\n            </div>\n        `;\n    MemoDoc.body.appendChild(modalElement);\n\n    modalDialogElement = modalElement.querySelector(`.${MODAL_CLASS_NAME}`);\n    modalTitleElement = modalElement.querySelector(`.${MODAL_TITLE_CLASS}`);\n    modalBodyElement = modalElement.querySelector(`.${MODAL_BODY_CLASS}`);\n    modalFooterElement = modalElement.querySelector(`.${MODAL_FOOTER_CLASS}`);\n\n    // 绑定关闭按钮事件\n    const closeButton = modalElement.querySelector(`.${MODAL_CLOSE_X_CLASS}`);\n    if (closeButton) {\n      closeButton.addEventListener('click', closeMemoModal);\n    }\n\n    // 绑定清除所有按钮事件\n    const clearAllButton = modalElement.querySelector('#memoClearAllBtn');\n    if (clearAllButton) {\n      clearAllButton.addEventListener('click', clearAllLocalMemos);\n\n      // 添加悬停效果\n      clearAllButton.addEventListener('mouseover', function () {\n        this.style.color = 'var(--SmartThemeQuoteColor, #4a9eff)';\n        this.style.transform = 'scale(1.1)';\n      });\n\n      clearAllButton.addEventListener('mouseout', function () {\n        this.style.color = 'var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7))';\n        this.style.transform = 'scale(1)';\n      });\n    }\n\n    // 点击背景关闭模态框\n    modalElement.addEventListener('click', (e) => {\n      if (e.target === modalElement) {\n        closeMemoModal();\n      }\n    });\n  }\n}\n\nfunction createButton(text, className, onClick) {\n  const button = MemoDoc.createElement('button');\n  button.textContent = text;\n  button.className = `memo-button ${className || ''}`;\n  button.onclick = onClick;\n  return button;\n}\n\nfunction renderMemoList() {\n  // 设置当前视图状态\n  state.currentView = 'list';\n\n  // 清理源上下文信息\n  state.currentSourceContext = null;\n\n  // 每次渲染时都重新获取当前聊天上下文\n  const newChatContext = getCurrentChatContext();\n\n  // 如果聊天上下文发生了变化且没有手动选择的上下文，更新当前上下文\n  if (currentChatContext !== newChatContext && !state.selectedChatContext) {\n    currentChatContext = newChatContext;\n  }\n\n  // 确定要显示的聊天上下文 - 优先使用手动选择的上下文\n  const displayContext = state.selectedChatContext || currentChatContext;\n\n  // 加载对应上下文的Memo数据\n  const memos = loadMemosFromStorage(displayContext);\n\n  // 根据当前排序设置进行排序\n  sortMemos(memos);\n\n  // 设置标题并添加齿轮图标（只在列表视图）\n  if (state.currentView === 'list') {\n    // 创建标题文本和按钮的容器\n    modalTitleElement.innerHTML = '';\n\n    // 创建标题文本节点\n    const titleText = MemoDoc.createTextNode('Memo');\n    modalTitleElement.appendChild(titleText);\n\n    // 创建设置按钮（内联显示）\n    const settingsBtn = MemoDoc.createElement('span');\n    settingsBtn.id = 'memoSettingsBtn';\n    settingsBtn.title = 'GitHub同步设置';\n    settingsBtn.innerHTML = '۞';\n    settingsBtn.style.cssText = `\n      display: inline-block;\n      background: transparent;\n      border: none;\n      color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8));\n      font-size: 18px;\n      cursor: pointer;\n      margin-left: 6px;\n      transition: all 0.2s ease;\n      position: relative;\n      top: 0px;\n      line-height: 1;\n    `;\n\n    settingsBtn.addEventListener('mouseover', function () {\n      this.style.color = 'var(--SmartThemeQuoteColor, #4a9eff)';\n      this.style.transform = 'rotate(30deg)';\n    });\n\n    settingsBtn.addEventListener('mouseout', function () {\n      this.style.color = 'var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8))';\n      this.style.transform = 'rotate(0deg)';\n    });\n\n    settingsBtn.addEventListener('click', function () {\n      renderGitHubSettings();\n    });\n\n    // 直接跟在文本后面添加按钮\n    modalTitleElement.appendChild(settingsBtn);\n  } else {\n    // 其他视图只显示标题文本\n    modalTitleElement.textContent = 'Memo';\n  }\n\n  // 显示当前聊天信息\n  let characterName = 'Unknown Character';\n  let chatName = 'Unknown Chat';\n\n  if (displayContext) {\n    // 从displayContext中提取角色名和聊天名\n    const parts = displayContext.split('-');\n    if (parts.length >= 2) {\n      characterName = parts[0].trim();\n      chatName = parts.slice(1).join('-').trim();\n    } else {\n      characterName = 'Unknown Character';\n      chatName = displayContext;\n    }\n  } else {\n    // 如果没有displayContext，尝试从TavernHelper或其他方法获取\n    if (window.TavernHelper && window.TavernHelper.substitudeMacros) {\n      try {\n        characterName = window.TavernHelper.substitudeMacros('{{char}}') || 'Unknown Character';\n        // 尝试获取聊天名，可能的宏包括这些\n        const possibleChatMacros = ['{{chatName}}', '{{chat_name}}', '{{filename}}', '{{chat}}'];\n        for (const macro of possibleChatMacros) {\n          const result = window.TavernHelper.substitudeMacros(macro);\n          if (result && result !== macro) { // 如果宏被成功替换了\n            chatName = result;\n            break;\n          }\n        }\n        // 如果上面的宏都没用，尝试传统方法\n        if (chatName === 'Unknown Chat') {\n          chatName = getCurrentChatName();\n        }\n      } catch (e) {\n        characterName = getCharacterName();\n        chatName = getCurrentChatName();\n      }\n    } else {\n      // 如果没有 TavernHelper，使用传统方法\n      characterName = getCharacterName();\n      chatName = getCurrentChatName();\n    }\n  }\n\n  // 获取所有聊天的Memo数据\n  const allChats = getAllMemoChats();\n\n  let html = `\n        <div class=\"memo-chat-info\" id=\"memoChatSelector\">\n            ${escapeHtml(characterName)} - ${escapeHtml(chatName)}\n            <div class=\"memo-chat-dropdown\" id=\"memoChatDropdown\">\n                ${allChats.map(chat => {\n    const isActive = chat.context === displayContext;\n    return `\n                    <div class=\"memo-chat-dropdown-item ${isActive ? 'active' : ''}\" data-chat-key=\"${chat.key}\" data-chat-context=\"${chat.context}\">\n                        <span>${escapeHtml(chat.name)}</span>\n                        <span class=\"memo-chat-dropdown-item-count\">${chat.count}</span>\n                    </div>\n                  `;\n  }).join('')}\n            </div>\n        </div>\n        \n        <!-- 筛选控制器 -->\n        <div class=\"memo-filter-container\" style=\"\n            margin-bottom: 16px;\n            padding: 8px 12px;\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.03));\n            border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n            border-radius: 10px;\n            display: flex;\n            align-items: center;\n            justify-content: space-between;\n            gap: 8px;\n            flex-wrap: nowrap;\n        \">\n            <div style=\"display: flex; align-items: center; gap: 6px; flex-shrink: 0;\">\n                <span style=\"\n                    font-size: 11px;\n                    color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8));\n                    font-weight: 500;\n                    white-space: nowrap;\n                \">排序：</span>\n                <div class=\"memo-filter-buttons\">\n                    <button class=\"memo-filter-btn ${state.sortBy === 'time' ? 'active' : ''}\" data-sort=\"time\">\n                        时间\n                    </button>\n                    <button class=\"memo-filter-btn ${state.sortBy === 'floor' ? 'active' : ''}\" data-sort=\"floor\">\n                        楼层\n                    </button>\n                </div>\n            </div>\n            <div style=\"display: flex; align-items: center; gap: 6px; flex-shrink: 0;\">\n                <span style=\"\n                    font-size: 11px;\n                    color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8));\n                    font-weight: 500;\n                    white-space: nowrap;\n                \">顺序：</span>\n                <button class=\"memo-order-btn ${state.sortOrder === 'desc' ? 'active' : ''}\" data-order=\"desc\" title=\"${state.sortBy === 'time' ? '最新在前' : '楼层号大在前'}\">\n                    ↓\n                </button>\n                <button class=\"memo-order-btn ${state.sortOrder === 'asc' ? 'active' : ''}\" data-order=\"asc\" title=\"${state.sortBy === 'time' ? '最旧在前' : '楼层号小在前'}\">\n                    ↑\n                </button>\n            </div>\n        </div>\n    `;\n\n  if (memos.length === 0) {\n    html += `\n            <div class=\"empty-memo-message\">\n                <p>暂无Memo</p>\n                <p>点击\"新建\"开始记录吧！</p>\n            </div>\n        `;\n  } else {\n    html += '<div class=\"memo-list-container\">';\n    memos.forEach((memo) => {\n      // 使用 getDisplayTitle 获取显示标题\n      const displayTitle = getDisplayTitle(memo);\n      // 显示最后编辑时间，如果没有则显示创建时间\n      const lastEditTime = memo.updatedAt || memo.createdAt;\n      const date = new Date(lastEditTime).toLocaleString('zh-CN');\n\n      // 生成楼层信息显示\n      const floorInfo = memo.floorLabel || (memo.type === 'annotation' ? '未知楼层' : '');\n\n      // 生成Memo项HTML\n      html += `\n                <div class=\"memo-item\" data-memo-id=\"${memo.id}\">\n                    <div class=\"memo-item-header\">\n                        <h4 class=\"memo-item-title\">${escapeHtml(displayTitle)}</h4>\n                        <div style=\"display: flex; align-items: center; gap: 8px;\">\n                            ${floorInfo ? `<span class=\"memo-item-floor\" style=\"\n                                font-size: 10px;\n                                color: #ffffff;\n                                background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.1));\n                                padding: 2px 6px;\n                                border-radius: 3px;\n                                white-space: nowrap;\n                                font-weight: 500;\n                                border: 1px solid var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2));\n                            \">${escapeHtml(floorInfo)}</span>` : ''}\n                        <span class=\"memo-item-date\">${date}</span>\n                        </div>\n                    </div>\n                    ${memo.type === 'annotation' && memo.originalText ? `\n                    <div class=\"memo-item-content\">\n                        ${escapeHtml(memo.content.length > 50 ? memo.content.substring(0, 50) + '...' : memo.content)}\n                    </div>\n                    ` : `\n                    <div class=\"memo-item-content\">\n                        ${escapeHtml(memo.content.length > 50 ? memo.content.substring(0, 50) + '...' : memo.content)}\n                    </div>\n                    `}\n                    <div class=\"memo-item-actions\">\n                        ${memo.type === 'annotation' && memo.originalText ? `\n                        <button class=\"memo-action-button primary\" data-memo-id=\"${memo.id}\" data-action=\"share\">分享</button>\n                        ` : ''}\n                        <button class=\"memo-action-button delete\" data-memo-id=\"${memo.id}\" data-action=\"delete\">删除</button>\n                    </div>\n                </div>\n            `;\n    });\n    html += '</div>';\n  }\n\n  modalBodyElement.innerHTML = html;\n\n  // 绑定聊天选择器点击事件\n  const chatSelector = modalBodyElement.querySelector('#memoChatSelector');\n  const chatDropdown = modalBodyElement.querySelector('#memoChatDropdown');\n\n  if (chatSelector && chatDropdown) {\n    // 点击选择器显示/隐藏下拉菜单\n    chatSelector.addEventListener('click', function (e) {\n      e.stopPropagation(); // 阻止冒泡\n\n      // 切换active类\n      this.classList.toggle('active');\n      chatDropdown.classList.toggle('show');\n\n      // 如果下拉菜单显示，确保它在最上层\n      if (chatDropdown.classList.contains('show')) {\n        // 添加一个临时的高z-index\n        chatDropdown.style.zIndex = '10002';\n        this.style.zIndex = '10000';\n      } else {\n        // 恢复默认z-index\n        setTimeout(() => {\n          chatDropdown.style.zIndex = '';\n          this.style.zIndex = '';\n        }, 300); // 等待过渡动画完成\n      }\n    });\n\n    // 点击下拉菜单项切换聊天\n    const dropdownItems = chatDropdown.querySelectorAll('.memo-chat-dropdown-item');\n    dropdownItems.forEach(item => {\n      item.addEventListener('click', function (e) {\n        e.stopPropagation(); // 阻止冒泡，防止触发chatSelector的点击事件\n        const chatContext = this.getAttribute('data-chat-context');\n        if (chatContext) {\n          // 更新手动选择的聊天上下文\n          state.selectedChatContext = chatContext;\n\n          // 重新渲染列表\n          renderMemoList();\n\n          // 关闭下拉菜单\n          chatSelector.classList.remove('active');\n          chatDropdown.classList.remove('show');\n\n          // 恢复默认z-index\n          setTimeout(() => {\n            chatDropdown.style.zIndex = '';\n            chatSelector.style.zIndex = '';\n          }, 300); // 等待过渡动画完成\n\n          // 显示切换成功提示\n          if (typeof toastr !== 'undefined') {\n            toastr.success(`已切换到 ${chatContext.replace('-', ' - ')} 的Memo记录`);\n          }\n        }\n      });\n    });\n\n    // 点击其他区域关闭下拉菜单\n    document.addEventListener('click', function () {\n      chatSelector.classList.remove('active');\n      chatDropdown.classList.remove('show');\n\n      // 恢复默认z-index\n      setTimeout(() => {\n        if (chatDropdown) chatDropdown.style.zIndex = '';\n        if (chatSelector) chatSelector.style.zIndex = '';\n      }, 300); // 等待过渡动画完成\n    });\n  }\n\n  // 绑定筛选控制器事件（无论是否有Memo都需要绑定）\n  bindFilterEvents();\n\n  // 绑定Memo操作按钮事件（只有在有Memo时才绑定）\n  if (memos.length > 0) {\n    bindMemoActionEvents();\n  }\n\n  // 渲染所有按钮到一个统一的行\n  modalFooterElement.innerHTML = '';\n\n  // 创建单行按钮容器\n  const buttonContainer = MemoDoc.createElement('div');\n  buttonContainer.style.display = 'flex';\n  buttonContainer.style.width = '100%';\n  buttonContainer.style.justifyContent = 'center';\n  buttonContainer.style.gap = '10px';\n\n  // 创建统一的按钮样式函数\n  const createUniformButton = (text, className, onClick) => {\n    const button = MemoDoc.createElement('button');\n    button.className = `memo-button ${className || ''}`;\n    button.textContent = text;\n    button.onclick = onClick;\n\n    // 统一的按钮样式，确保相同大小\n    button.style.flex = '1';\n    button.style.maxWidth = '80px';\n    button.style.fontSize = '14px';\n    button.style.padding = '8px 0';\n    button.style.borderRadius = '6px';\n    button.style.textAlign = 'center';\n    button.style.whiteSpace = 'nowrap';\n\n    return button;\n  };\n\n  // 创建四个按钮\n  const newButton = createUniformButton('新建', 'primary', () => renderCreateMemo());\n  const importButton = createUniformButton('导入', 'secondary', () => {\n    const fileSelector = createFileSelector();\n    fileSelector.click();\n  });\n  const exportButton = createUniformButton('导出', 'secondary', () => exportAllMemos());\n  const yearlyReportButton = createUniformButton('使用报告', 'secondary', () => renderYearlyReportGenerator());\n  const deleteButton = createUniformButton('删除', 'danger', () => clearCurrentChatMemos());\n\n  // 添加所有按钮到容器\n  buttonContainer.appendChild(newButton);\n  buttonContainer.appendChild(importButton);\n  buttonContainer.appendChild(exportButton);\n  buttonContainer.appendChild(yearlyReportButton);\n  buttonContainer.appendChild(deleteButton);\n\n  // 添加按钮容器到页脚\n  modalFooterElement.appendChild(buttonContainer);\n\n  // 重新居中模态框\n  requestAnimationFrame(() => {\n    centerModal();\n  });\n}\n\n// 添加获取所有Memo聊天的函数\nfunction getAllMemoChats() {\n  const chats = [];\n\n  // 遍历localStorage中所有以memo_开头的键\n  for (let i = 0; i < localStorage.length; i++) {\n    const key = localStorage.key(i);\n    if (key && key.startsWith(LOCAL_STORAGE_KEY_PREFIX) && key !== GITHUB_CONFIG_KEY) {\n      try {\n        // 从键名中提取聊天上下文\n        const contextPart = key.substring(LOCAL_STORAGE_KEY_PREFIX.length);\n\n        // 尝试解析数据以获取条目数量\n        const data = JSON.parse(localStorage.getItem(key) || '[]');\n        const count = Array.isArray(data) ? data.length : 0;\n\n        // 只添加有memo记录的聊天\n        if (count > 0) {\n          // 提取角色名和聊天名\n          let displayName = contextPart;\n          const parts = contextPart.split('-');\n          if (parts.length >= 2) {\n            const charName = parts[0].trim();\n            const chatName = parts.slice(1).join('-').trim();\n            displayName = `${charName} - ${chatName}`;\n          }\n\n          chats.push({\n            key: key,\n            context: contextPart,\n            name: displayName,\n            count: count\n          });\n        }\n      } catch (e) {\n        console.error(`解析Memo聊天数据时出错:`, e);\n      }\n    }\n  }\n\n  // 按照条目数量排序，多的在前面\n  chats.sort((a, b) => b.count - a.count);\n\n  return chats;\n}\n\n// 添加切换到指定聊天的函数\nfunction switchToChat(chatKey) {\n  if (!chatKey) return;\n\n  try {\n    // 从键名中提取聊天上下文\n    const contextPart = chatKey.substring(LOCAL_STORAGE_KEY_PREFIX.length);\n\n    // 更新当前聊天上下文\n    currentChatContext = contextPart;\n\n    // 重新渲染列表\n    renderMemoList();\n\n    // 显示切换成功提示\n    if (typeof toastr !== 'undefined') {\n      toastr.success(`已切换到 ${contextPart.replace('-', ' - ')} 的Memo记录`);\n    }\n  } catch (e) {\n    console.error('切换聊天失败:', e);\n    if (typeof toastr !== 'undefined') {\n      toastr.error('切换聊天失败');\n    }\n  }\n}\n\n// Memo排序函数\nfunction sortMemos(memos) {\n  if (state.sortBy === 'time') {\n    // 按时间排序\n    memos.sort((a, b) => {\n      const timeA = new Date(a.updatedAt || a.createdAt);\n      const timeB = new Date(b.updatedAt || b.createdAt);\n      return state.sortOrder === 'desc' ? timeB - timeA : timeA - timeB;\n    });\n  } else if (state.sortBy === 'floor') {\n    // 按楼层排序\n    memos.sort((a, b) => {\n      // 获取楼层号，特殊处理跨楼层和手动创建的情况\n      const getFloorNumber = (memo) => {\n        if (!memo.messageId || memo.messageId === '-' || memo.floorLabel === '手动创建' || memo.floorLabel === '跨楼层' || memo.floorLabel === '未知楼层') {\n          return Number.MAX_SAFE_INTEGER; // 放到最后\n        }\n        return typeof memo.messageId === 'number' ? memo.messageId : parseInt(memo.messageId) || Number.MAX_SAFE_INTEGER;\n      };\n\n      const floorA = getFloorNumber(a);\n      const floorB = getFloorNumber(b);\n\n      // 如果两个都是特殊情况（都是MAX_SAFE_INTEGER），按时间排序\n      if (floorA === Number.MAX_SAFE_INTEGER && floorB === Number.MAX_SAFE_INTEGER) {\n        const timeA = new Date(a.updatedAt || a.createdAt);\n        const timeB = new Date(b.updatedAt || b.createdAt);\n        return timeB - timeA; // 最新的在前\n      }\n\n      return state.sortOrder === 'desc' ? floorB - floorA : floorA - floorB;\n    });\n  }\n}\n\n// 绑定筛选控制器事件\nfunction bindFilterEvents() {\n  // 绑定排序方式按钮\n  const filterButtons = modalBodyElement?.querySelectorAll('.memo-filter-btn');\n  if (filterButtons) {\n    filterButtons.forEach(button => {\n      button.addEventListener('click', (e) => {\n        const sortBy = e.target.getAttribute('data-sort');\n        if (sortBy && sortBy !== state.sortBy) {\n          state.sortBy = sortBy;\n          if (typeof toastr !== 'undefined') {\n            toastr.info(`已切换到${sortBy === 'time' ? '时间' : '楼层'}排序`);\n          }\n          renderMemoList(); // 重新渲染列表\n        }\n      });\n    });\n  }\n\n  // 绑定排序顺序按钮\n  const orderButtons = modalBodyElement?.querySelectorAll('.memo-order-btn');\n  if (orderButtons) {\n    orderButtons.forEach(button => {\n      button.addEventListener('click', (e) => {\n        const sortOrder = e.target.getAttribute('data-order');\n        if (sortOrder && sortOrder !== state.sortOrder) {\n          state.sortOrder = sortOrder;\n          const orderText = sortOrder === 'desc' ?\n            (state.sortBy === 'time' ? '最新在前' : '楼层号大在前') :\n            (state.sortBy === 'time' ? '最旧在前' : '楼层号小在前');\n          if (typeof toastr !== 'undefined') {\n            toastr.info(`排序顺序：${orderText}`);\n          }\n          renderMemoList(); // 重新渲染列表\n        }\n      });\n    });\n  }\n}\n\n// 绑定Memo操作按钮事件\nfunction bindMemoActionEvents() {\n  // 绑定Memo框点击事件（进入编辑模式）\n  const memoItems = modalBodyElement.querySelectorAll('.memo-item');\n  memoItems.forEach(item => {\n    item.addEventListener('click', (e) => {\n      // 如果点击的是按钮，不触发编辑\n      if (e.target.classList.contains('memo-action-button')) {\n        return;\n      }\n\n      const memoId = parseInt(item.getAttribute('data-memo-id'));\n      if (memoId) {\n        editMemo(memoId);\n      }\n    });\n  });\n\n  // 绑定删除按钮事件\n  const actionButtons = modalBodyElement.querySelectorAll('.memo-action-button');\n  actionButtons.forEach(button => {\n    button.addEventListener('click', (e) => {\n      e.stopPropagation(); // 阻止事件冒泡到父元素\n      const memoId = parseInt(e.target.getAttribute('data-memo-id'));\n      const action = e.target.getAttribute('data-action');\n\n      if (action === 'share') {\n        shareMemo(memoId);\n      } else if (action === 'delete') {\n        deleteMemo(memoId);\n      }\n    });\n  });\n}\n\nfunction renderCreateMemo() {\n  renderCreateMemoWithParagraph('', null);\n}\n\nfunction renderCreateMemoWithParagraph(paragraphText = '', sourceContext = null) {\n  // 设置当前视图状态\n  state.currentView = 'create';\n\n  // 确保使用正确的聊天上下文 - 优先使用手动选择的上下文\n  const displayContext = state.selectedChatContext || getCurrentChatContext();\n\n  // 存储源上下文信息，用于后续保存时确定楼层\n  state.currentSourceContext = sourceContext;\n\n  // 从displayContext中提取角色名和聊天名\n  let characterName = 'Unknown Character';\n  let chatName = 'Unknown Chat';\n\n  if (displayContext) {\n    const parts = displayContext.split('-');\n    if (parts.length >= 2) {\n      characterName = parts[0].trim();\n      chatName = parts.slice(1).join('-').trim();\n    } else {\n      chatName = displayContext;\n    }\n  }\n\n  modalTitleElement.textContent = paragraphText ? '为段落创建Memo' : '新建Memo';\n\n  // 加载Font Awesome，如果尚未加载\n  ensureFontAwesomeLoaded();\n\n  // 直接创建DOM元素而不是使用HTML字符串\n  // 清空modalBodyElement\n  modalBodyElement.innerHTML = '';\n\n  // 创建表单容器\n  const formContainer = MemoDoc.createElement('div');\n  formContainer.className = 'memo-form';\n\n  // 创建聊天信息\n  const chatInfoDiv = MemoDoc.createElement('div');\n  chatInfoDiv.className = 'memo-chat-info';\n  chatInfoDiv.style.cursor = 'default';\n  chatInfoDiv.style.marginBottom = '20px';\n  chatInfoDiv.textContent = `保存到：${characterName} - ${chatName}`;\n  formContainer.appendChild(chatInfoDiv);\n\n  // 创建标题输入组\n  const titleGroup = MemoDoc.createElement('div');\n  titleGroup.className = 'memo-form-group';\n\n  const titleLabel = MemoDoc.createElement('label');\n  titleLabel.className = 'memo-form-label';\n  titleLabel.htmlFor = MEMO_TITLE_INPUT_ID;\n  titleLabel.textContent = '标题（可选）：';\n  titleGroup.appendChild(titleLabel);\n\n  const titleInput = MemoDoc.createElement('input');\n  titleInput.type = 'text';\n  titleInput.id = MEMO_TITLE_INPUT_ID;\n  titleInput.placeholder = '留空将自动生成标题...';\n  titleInput.value = '';\n  titleGroup.appendChild(titleInput);\n\n  formContainer.appendChild(titleGroup);\n\n  // 如果有段落文本，创建原文段落输入组\n  if (paragraphText) {\n    const originalGroup = MemoDoc.createElement('div');\n    originalGroup.className = 'memo-form-group';\n\n    const originalLabel = MemoDoc.createElement('label');\n    originalLabel.className = 'memo-form-label';\n    originalLabel.htmlFor = 'memoOriginalTextInput';\n    originalLabel.textContent = '原文段落（可编辑）：';\n    originalGroup.appendChild(originalLabel);\n\n    const originalContainer = MemoDoc.createElement('div');\n    originalContainer.className = 'memo-textarea-container';\n    originalContainer.style.position = 'relative';\n\n    const originalTextarea = MemoDoc.createElement('textarea');\n    originalTextarea.id = 'memoOriginalTextInput';\n    originalTextarea.style.cssText = `\n      padding: 12px 16px;\n      border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n      border-radius: 10px;\n      background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n      color: var(--SmartThemeBodyColor, #ffffff);\n      min-height: 100px;\n      max-height: 150px;\n      resize: vertical;\n      font-family: inherit;\n      font-size: 14px;\n      line-height: 1.6;\n      transition: all 0.3s ease;\n      width: 100%;\n      box-sizing: border-box;\n      margin-bottom: 8px;\n    `;\n    originalTextarea.placeholder = '编辑原文段落内容...';\n    originalTextarea.value = paragraphText;\n    originalContainer.appendChild(originalTextarea);\n\n    const originalCopyBtn = MemoDoc.createElement('button');\n    originalCopyBtn.className = 'memo-copy-button';\n    originalCopyBtn.title = '复制原文内容';\n    originalCopyBtn.setAttribute('data-target', 'memoOriginalTextInput');\n    originalCopyBtn.style.cssText = `\n      position: absolute;\n      top: 8px;\n      right: 8px;\n      background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.1));\n      color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7));\n      border: none;\n      padding: 4px;\n      font-size: 12px;\n      border-radius: 4px;\n      cursor: pointer;\n      transition: all 0.2s ease;\n      width: 24px;\n      height: 24px;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      opacity: 0.7;\n      z-index: 10002;\n    `;\n\n    const originalIcon = MemoDoc.createElement('i');\n    originalIcon.className = 'fa-regular fa-clone';\n    originalCopyBtn.appendChild(originalIcon);\n    originalContainer.appendChild(originalCopyBtn);\n\n    originalGroup.appendChild(originalContainer);\n    formContainer.appendChild(originalGroup);\n  }\n\n  // 创建内容输入组\n  const contentGroup = MemoDoc.createElement('div');\n  contentGroup.className = 'memo-form-group';\n\n  const contentLabel = MemoDoc.createElement('label');\n  contentLabel.className = 'memo-form-label';\n  contentLabel.htmlFor = MEMO_INPUT_ID;\n  contentLabel.textContent = '内容：';\n  contentGroup.appendChild(contentLabel);\n\n  const contentContainer = MemoDoc.createElement('div');\n  contentContainer.className = 'memo-textarea-container';\n  contentContainer.style.position = 'relative';\n\n  const contentTextarea = MemoDoc.createElement('textarea');\n  contentTextarea.id = MEMO_INPUT_ID;\n  contentTextarea.placeholder = paragraphText ? '记下你现在的想法吧...' : '请输入笔记内容...';\n  contentTextarea.style.cssText = `\n    padding: 12px 16px;\n    border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n    border-radius: 10px;\n    background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n    color: var(--SmartThemeBodyColor, #ffffff);\n    min-height: 140px;\n    resize: vertical;\n    font-family: inherit;\n    font-size: 14px;\n    line-height: 1.6;\n    transition: all 0.3s ease;\n    width: 100%;\n    box-sizing: border-box;\n  `;\n  contentContainer.appendChild(contentTextarea);\n\n  const contentCopyBtn = MemoDoc.createElement('button');\n  contentCopyBtn.className = 'memo-copy-button';\n  contentCopyBtn.title = '复制笔记内容';\n  contentCopyBtn.setAttribute('data-target', MEMO_INPUT_ID);\n  contentCopyBtn.style.cssText = `\n    position: absolute;\n    top: 8px;\n    right: 8px;\n    background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.1));\n    color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7));\n    border: none;\n    padding: 4px;\n    font-size: 12px;\n    border-radius: 4px;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    width: 24px;\n    height: 24px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    opacity: 0.7;\n    z-index: 10002;\n  `;\n\n  const contentIcon = MemoDoc.createElement('i');\n  contentIcon.className = 'fa-regular fa-clone';\n  contentCopyBtn.appendChild(contentIcon);\n  contentContainer.appendChild(contentCopyBtn);\n\n  contentGroup.appendChild(contentContainer);\n  formContainer.appendChild(contentGroup);\n\n  // 将表单添加到模态框\n  modalBodyElement.appendChild(formContainer);\n\n  // 检查复制按钮是否正确创建\n  setTimeout(() => {\n    const copyButtons = modalBodyElement.querySelectorAll('.memo-copy-button');\n    copyButtons.forEach((btn) => {\n      // 绑定点击事件\n      btn.addEventListener('click', function (e) {\n        e.stopPropagation();\n        const targetId = this.getAttribute('data-target');\n        const textArea = MemoDoc.getElementById(targetId);\n        if (textArea) {\n          copyTextFromTextarea(textArea);\n        }\n      });\n    });\n  }, 100);\n\n  // 为原文textarea添加focus样式\n  if (paragraphText) {\n    const originalTextInput = MemoDoc.getElementById('memoOriginalTextInput');\n    if (originalTextInput) {\n      originalTextInput.addEventListener('focus', function () {\n        this.style.borderColor = 'var(--SmartThemeQuoteColor, #4a9eff)';\n        this.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.08))';\n        this.style.boxShadow = '0 0 0 3px var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2))';\n      });\n      originalTextInput.addEventListener('blur', function () {\n        this.style.borderColor = 'var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1))';\n        this.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05))';\n        this.style.boxShadow = 'none';\n      });\n    }\n  }\n\n  // 渲染底部按钮\n  modalFooterElement.innerHTML = '';\n  modalFooterElement.appendChild(createButton('保存', 'primary', saveMemo));\n  modalFooterElement.appendChild(createButton('取消', 'secondary', () => renderMemoList()));\n\n  // 重新居中模态框\n  requestAnimationFrame(() => {\n    centerModal();\n  });\n\n  // 聚焦到合适的输入框\n  setTimeout(() => {\n    if (paragraphText) {\n      // 如果是段落注释，聚焦到内容输入框\n      const contentInput = MemoDoc.getElementById(MEMO_INPUT_ID);\n      if (contentInput) contentInput.focus();\n    } else {\n      // 如果是新建Memo，聚焦到内容输入框\n      const contentInput = MemoDoc.getElementById(MEMO_INPUT_ID);\n      if (contentInput) contentInput.focus();\n    }\n  }, 100);\n}\n\nfunction renderEditMemo(memoId) {\n  // 设置当前视图状态\n  state.currentView = 'edit';\n\n  // 确保使用正确的聊天上下文 - 优先使用手动选择的上下文\n  const displayContext = state.selectedChatContext || getCurrentChatContext();\n\n  const memos = loadMemosFromStorage(displayContext);\n  const memo = memos.find(m => m.id === memoId);\n\n  if (!memo) {\n    toastr.error('Memo不存在！');\n    renderMemoList();\n    return;\n  }\n\n  modalTitleElement.textContent = '编辑Memo';\n  state.editingMemoId = memoId;\n\n  // 从displayContext中提取角色名和聊天名\n  let characterName = 'Unknown Character';\n  let chatName = 'Unknown Chat';\n\n  if (displayContext) {\n    const parts = displayContext.split('-');\n    if (parts.length >= 2) {\n      characterName = parts[0].trim();\n      chatName = parts.slice(1).join('-').trim();\n    } else {\n      chatName = displayContext;\n    }\n  }\n\n  // 加载Font Awesome，如果尚未加载\n  ensureFontAwesomeLoaded();\n\n  const html = `\n        <div class=\"memo-form\">\n            <div class=\"memo-chat-info\" style=\"cursor: default; margin-bottom: 20px;\">\n                保存到：${escapeHtml(characterName)} - ${escapeHtml(chatName)}\n            </div>\n            <div class=\"memo-form-group\">\n                <label class=\"memo-form-label\" for=\"${MEMO_TITLE_INPUT_ID}\">标题（可选）：</label>\n                <input type=\"text\" id=\"${MEMO_TITLE_INPUT_ID}\" \n                       placeholder=\"留空将自动生成标题...\" \n                       value=\"${escapeHtml(memo.title || '')}\" />\n            </div>\n            ${memo.type === 'annotation' && memo.originalText ? `\n            <div class=\"memo-form-group\">\n                <label class=\"memo-form-label\" for=\"memoOriginalTextInput\">原文段落（可编辑）：</label>\n                <div class=\"memo-textarea-container\">\n                    <button class=\"memo-copy-button\" title=\"复制原文内容\" data-target=\"memoOriginalTextInput\">\n                        <i class=\"fa-regular fa-clone\"></i>\n                    </button>\n                    <textarea id=\"memoOriginalTextInput\" \n                             style=\"padding: 12px 16px;\n                                    border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                                    border-radius: 10px;\n                                    background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n                                    color: var(--SmartThemeBodyColor, #ffffff);\n                                    min-height: 100px;\n                                    max-height: 150px;\n                                    resize: vertical;\n                                    font-family: inherit;\n                                    font-size: 14px;\n                                    line-height: 1.6;\n                                    transition: all 0.3s ease;\n                                    width: 100%;\n                                    box-sizing: border-box;\n                                    margin-bottom: 8px;\"\n                             placeholder=\"编辑原文段落内容...\">${escapeHtml(memo.originalText)}</textarea>\n                </div>\n            </div>\n            ` : ''}\n            <div class=\"memo-form-group\">\n                <label class=\"memo-form-label\" for=\"${MEMO_INPUT_ID}\">内容：</label>\n                <div class=\"memo-textarea-container\">\n                    <button class=\"memo-copy-button\" title=\"复制笔记内容\" data-target=\"${MEMO_INPUT_ID}\">\n                        <i class=\"fa-regular fa-clone\"></i>\n                    </button>\n                    <textarea id=\"${MEMO_INPUT_ID}\">${escapeHtml(memo.content)}</textarea>\n                </div>\n            </div>\n        </div>\n    `;\n\n  modalBodyElement.innerHTML = html;\n\n  // 为原文textarea添加focus样式\n  if (memo.type === 'annotation' && memo.originalText) {\n    const originalTextInput = MemoDoc.getElementById('memoOriginalTextInput');\n    if (originalTextInput) {\n      originalTextInput.addEventListener('focus', function () {\n        this.style.borderColor = 'var(--SmartThemeQuoteColor, #4a9eff)';\n        this.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.08))';\n        this.style.boxShadow = '0 0 0 3px var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2))';\n      });\n      originalTextInput.addEventListener('blur', function () {\n        this.style.borderColor = 'var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1))';\n        this.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05))';\n        this.style.boxShadow = 'none';\n      });\n    }\n  }\n\n  // 绑定复制按钮事件\n  const copyButtons = modalBodyElement.querySelectorAll('.memo-copy-button');\n  copyButtons.forEach(button => {\n    button.addEventListener('click', function (e) {\n      e.stopPropagation();\n      const targetId = this.getAttribute('data-target');\n      const textArea = MemoDoc.getElementById(targetId);\n      if (textArea) {\n        copyTextFromTextarea(textArea);\n      }\n    });\n  });\n\n  // 渲染底部按钮\n  modalFooterElement.innerHTML = '';\n  modalFooterElement.appendChild(createButton('保存修改', 'primary', updateMemo));\n  modalFooterElement.appendChild(createButton('取消', 'secondary', () => renderMemoList()));\n\n  // 重新居中模态框\n  requestAnimationFrame(() => {\n    centerModal();\n  });\n}\n\n\nfunction saveMemo() {\n  const titleInput = MemoDoc.getElementById(MEMO_TITLE_INPUT_ID);\n  const contentInput = MemoDoc.getElementById(MEMO_INPUT_ID);\n  const originalTextInput = MemoDoc.getElementById('memoOriginalTextInput');\n\n  if (!titleInput || !contentInput) {\n    toastr.error('找不到输入框！');\n    return;\n  }\n\n  const title = titleInput.value.trim();\n  const content = contentInput.value.trim();\n  const originalText = originalTextInput ? originalTextInput.value.trim() : '';\n\n  // 如果既没有原文又没有内容，才提示错误\n  // 有原文的memo可以不填写笔记内容\n  if (!content && !originalText) {\n    toastr.warning('请输入Memo内容！');\n    contentInput.focus();\n    return;\n  }\n\n  // 确定要使用的聊天上下文 - 优先使用手动选择的上下文\n  const saveContext = state.selectedChatContext || getCurrentChatContext();\n  console.log('保存Memo到聊天上下文:', saveContext); // 调试日志\n\n  const memos = loadMemosFromStorage(saveContext);\n\n  // 计算楼层信息\n  let messageId = null;\n  let floorLabel = '手动创建';\n\n  if (originalText && state.currentSourceContext) {\n    // 如果是段落Memo且有源上下文信息，使用上下文中的楼层信息\n    messageId = state.currentSourceContext.messageId;\n    floorLabel = state.currentSourceContext.floorLabel;\n  } else if (originalText) {\n    // 兼容旧代码：如果是段落Memo但没有源上下文信息\n    if (selectionState.selectedParagraphs && selectionState.selectedParagraphs.length > 0) {\n      // 多选模式：检查是否跨楼层\n      const messageIds = selectionState.selectedParagraphs\n        .map(p => p.messageId)\n        .filter(id => id !== null && id !== undefined);\n\n      if (messageIds.length === 0) {\n        messageId = null;\n        floorLabel = '未知楼层';\n      } else {\n        const uniqueMessageIds = [...new Set(messageIds)];\n        if (uniqueMessageIds.length === 1) {\n          // 同楼层\n          messageId = uniqueMessageIds[0];\n          floorLabel = generateFloorLabel(messageId);\n        } else {\n          // 跨楼层\n          messageId = '-';\n          floorLabel = '跨楼层';\n        }\n      }\n    } else {\n      // 单选模式：尝试从当前DOM解析楼层（这个情况比较少见，因为通常都是通过按钮触发的）\n      messageId = null;\n      floorLabel = '未知楼层';\n    }\n  }\n\n  const newMemo = {\n    id: Date.now(),\n    title: title,\n    content: content,\n    originalText: originalText, // 保存原始段落文本\n    type: originalText ? 'annotation' : 'normal', // 标记Memo类型\n    messageId: messageId, // 楼层ID\n    floorLabel: floorLabel, // 楼层显示标签\n    createdAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString()\n  };\n\n  memos.push(newMemo);\n  saveMemosToStorage(saveContext, memos);\n\n  // 清理源上下文信息\n  state.currentSourceContext = null;\n\n  toastr.success(originalText ? `段落Memo已保存到 \"${saveContext.replace('-', ' - ')}\"！` : `Memo已保存到 \"${saveContext.replace('-', ' - ')}\"！`);\n  renderMemoList();\n}\n\nfunction updateMemo() {\n  const titleInput = MemoDoc.getElementById(MEMO_TITLE_INPUT_ID);\n  const contentInput = MemoDoc.getElementById(MEMO_INPUT_ID);\n  const originalTextInput = MemoDoc.getElementById('memoOriginalTextInput');\n\n  if (!titleInput || !contentInput) {\n    toastr.error('找不到输入框！');\n    return;\n  }\n\n  const title = titleInput.value.trim();\n  const content = contentInput.value.trim();\n  const originalText = originalTextInput ? originalTextInput.value.trim() : '';\n\n  // 如果既没有原文又没有内容，才提示错误  \n  // 有原文的memo可以不填写笔记内容\n  if (!content && !originalText) {\n    toastr.warning('请输入Memo内容！');\n    contentInput.focus();\n    return;\n  }\n\n  // 确定要使用的聊天上下文 - 优先使用手动选择的上下文\n  const saveContext = state.selectedChatContext || getCurrentChatContext();\n  const memos = loadMemosFromStorage(saveContext);\n  const memoId = state.editingMemoId;\n\n  const memoIndex = memos.findIndex(m => m.id === memoId);\n  if (memoIndex !== -1) {\n    memos[memoIndex].title = title;\n    memos[memoIndex].content = content;\n    // 如果有原文输入框，也更新原文内容\n    if (originalTextInput) {\n      memos[memoIndex].originalText = originalText;\n    }\n    memos[memoIndex].updatedAt = new Date().toISOString();\n\n    saveMemosToStorage(saveContext, memos);\n    toastr.success('Memo已更新！');\n    renderMemoList();\n  } else {\n    toastr.error('Memo不存在！');\n    renderMemoList();\n  }\n}\n\nfunction deleteMemo(memoId) {\n  if (!confirm('确定要删除这条Memo吗？')) {\n    return;\n  }\n\n  // 确定要使用的聊天上下文 - 优先使用手动选择的上下文\n  const saveContext = state.selectedChatContext || getCurrentChatContext();\n  const memos = loadMemosFromStorage(saveContext);\n  const memoIndex = memos.findIndex(m => m.id === memoId);\n\n  if (memoIndex !== -1) {\n    memos.splice(memoIndex, 1);\n    saveMemosToStorage(saveContext, memos);\n    toastr.success('Memo已删除！');\n    renderMemoList();\n  } else {\n    toastr.error('Memo不存在！');\n  }\n}\n\nfunction editMemo(memoId) {\n  renderEditMemo(memoId);\n}\n\nfunction centerModal() {\n  if (!modalDialogElement) return;\n\n  const windowWidth = window.innerWidth || MemoDoc.documentElement.clientWidth || MemoDoc.body.clientWidth;\n  const windowHeight = window.innerHeight || MemoDoc.documentElement.clientHeight || MemoDoc.body.clientHeight;\n\n  const dialogWidth = modalDialogElement.offsetWidth || 750;\n  const dialogHeight = modalDialogElement.offsetHeight || 600;\n\n  const left = Math.max(0, (windowWidth - dialogWidth) / 2);\n  const top = Math.max(0, (windowHeight - dialogHeight) / 2);\n\n  modalDialogElement.style.left = `${left}px`;\n  modalDialogElement.style.top = `${top}px`;\n}\n\nfunction openMemoModal() {\n  ensureModalStructure();\n  modalElement.style.display = 'block';\n\n  // 重置手动选择的聊天上下文\n  state.selectedChatContext = null;\n\n  // 加载GitHub配置\n  loadGitHubConfig();\n  \n  // 加载LLM配置\n  loadLLMConfig();\n  \n  // 加载样式偏好\n  const savedStyle = loadStylePreference();\n  console.log('Memo: 已加载样式偏好:', savedStyle);\n\n  // 如果没有菜单按钮，创建一个\n  createMemoMenuButton();\n\n  // 等待一帧以确保DOM已渲染完成，然后居中显示\n  requestAnimationFrame(() => {\n    centerModal();\n  });\n\n  renderMemoList();\n\n  // 监听聊天切换事件\n  setupChatChangeListener();\n\n  // 监听窗口大小变化，重新居中\n  window.addEventListener('resize', centerModal);\n\n  // 添加ESC键关闭模态框\n  MemoDoc.addEventListener('keydown', (e) => {\n    if (e.key === 'Escape') {\n      closeMemoModal();\n    }\n  });\n}\n\nfunction closeMemoModal() {\n  if (modalElement) {\n    modalElement.style.display = 'none';\n  }\n\n  // 移除聊天切换事件监听器\n  removeChatChangeListener();\n\n  // 移除窗口大小变化监听器\n  window.removeEventListener('resize', centerModal);\n\n  state.currentView = 'list';\n  state.editingMemoId = null;\n  state.currentSourceContext = null;  // 清理源上下文信息\n}\n\n// 设置聊天切换事件监听器\nfunction setupChatChangeListener() {\n  // 移除之前的监听器（如果存在）\n  removeChatChangeListener();\n\n  // 创建事件处理函数\n  chatChangeListener = function (event) {\n    // 只在模态框打开且在列表视图时才自动刷新\n    if (modalElement && modalElement.style.display === 'block' && state.currentView === 'list') {\n      const newContext = getCurrentChatContext();\n      if (currentChatContext !== newContext) {\n        // 更新当前聊天上下文\n        currentChatContext = newContext;\n\n        // 如果没有手动选择的聊天，则刷新显示\n        if (!state.selectedChatContext) {\n          renderMemoList();\n        }\n      }\n    }\n  };\n\n  // 尝试监听多种可能的聊天切换事件\n  const eventTypes = [\n    'CHAT_CHANGED',\n    'chat_changed',\n    'chatChanged',\n    'character_selected',\n    'CHARACTER_SELECTED'\n  ];\n\n  eventTypes.forEach(eventType => {\n    try {\n      // 尝试监听 document 上的自定义事件\n      MemoDoc.addEventListener(eventType, chatChangeListener);\n    } catch (e) {\n      // 静默忽略注册失败\n    }\n  });\n\n  // 如果存在 eventSource 或其他事件分发器，也尝试监听\n  if (window.eventSource && typeof window.eventSource.addEventListener === 'function') {\n    try {\n      window.eventSource.addEventListener('CHAT_CHANGED', chatChangeListener);\n    } catch (e) {\n      // 静默忽略注册失败\n    }\n  }\n}\n\n// 移除聊天切换事件监听器\nfunction removeChatChangeListener() {\n  if (chatChangeListener) {\n    const eventTypes = [\n      'CHAT_CHANGED',\n      'chat_changed',\n      'chatChanged',\n      'character_selected',\n      'CHARACTER_SELECTED'\n    ];\n\n    eventTypes.forEach(eventType => {\n      try {\n        MemoDoc.removeEventListener(eventType, chatChangeListener);\n      } catch (e) {\n        // 静默忽略移除失败\n      }\n    });\n\n    if (window.eventSource && typeof window.eventSource.removeEventListener === 'function') {\n      try {\n        window.eventSource.removeEventListener('CHAT_CHANGED', chatChangeListener);\n      } catch (e) {\n        // 静默忽略移除失败\n      }\n    }\n\n    chatChangeListener = null;\n  }\n}\n\n\nfunction escapeHtml(text) {\n  const div = MemoDoc.createElement('div');\n  div.textContent = text;\n  return div.innerHTML;\n}\n\n// 生成显示用的标题\nfunction getDisplayTitle(memo) {\n  // 如果有自定义标题，直接使用\n  if (memo.title && memo.title.trim()) {\n    return memo.title.trim();\n  }\n\n  // 没有标题时，根据类型生成\n  if (memo.type === 'annotation' && memo.originalText && memo.originalText.trim()) {\n\n    const text = memo.originalText.trim();\n    return text.length > 8 ? text.substring(0, 8) + '...' : text;\n  } else if (memo.content && memo.content.trim()) {\n\n    const text = memo.content.trim();\n    return text.length > 8 ? text.substring(0, 8) + '...' : text;\n  } else {\n\n    return '无标题Memo';\n  }\n}\n\nfunction createMemoMenuButton(retryCount = 0) {\n  const MAX_RETRIES = 5;\n  const RETRY_DELAY = 500;\n\n  if (MemoDoc.getElementById(MENU_BUTTON_ID)) {\n    return;\n  }\n\n  const extensionsMenu = MemoDoc.getElementById('extensions_menu') || MemoDoc.getElementById('extensionsMenu');\n\n  if (extensionsMenu) {\n    const menuButton = MemoDoc.createElement('div');\n    menuButton.id = MENU_BUTTON_ID;\n    menuButton.className = 'list-group-item flex-container flexGap5 interactable';\n    menuButton.setAttribute('tabindex', '0');\n    menuButton.title = 'Memo';\n\n    const iconSpan = MemoDoc.createElement('span');\n    iconSpan.textContent = '✎';\n    menuButton.appendChild(iconSpan);\n\n    const textSpan = MemoDoc.createElement('span');\n    textSpan.textContent = 'Memo';\n    menuButton.appendChild(textSpan);\n\n    menuButton.onclick = openMemoModal;\n    extensionsMenu.prepend(menuButton);\n  } else {\n    if (retryCount < MAX_RETRIES) {\n      setTimeout(() => createMemoMenuButton(retryCount + 1), RETRY_DELAY);\n    }\n  }\n}\n\nwindow.closeMemoModal = closeMemoModal;\n\nfunction initializeMemo() {\n  if (MemoDoc.readyState === 'loading') {\n    MemoDoc.addEventListener('DOMContentLoaded', () => {\n      setTimeout(() => {\n        // 加载GitHub配置\n        loadGitHubConfig();\n        \n        // 加载LLM配置\n        loadLLMConfig();\n        \n        // 加载样式偏好\n        const savedStyle = loadStylePreference();\n        console.log('Memo: 已加载样式偏好:', savedStyle);\n\n        // 加载自定义颜色配置\n        loadCustomColorConfig();\n        console.log('Memo: 已加载自定义颜色配置');\n\n        // 加载字体配置\n        loadFontPreference();\n        loadCustomFonts();\n        loadAllCustomFonts().then(() => {\n          console.log('Memo: 已加载所有网络字体');\n        }).catch(error => {\n          console.error('Memo: 加载网络字体失败:', error);\n        });\n\n        // 如果没有菜单按钮，创建一个\n        createMemoMenuButton();\n\n        // 页面卸载时清理事件监听器\n        window.addEventListener('beforeunload', () => {\n          removeChatChangeListener();\n        });\n      }, 1000);\n    });\n  } else {\n    try {\n      // 清理之前可能存在的事件监听器\n      removeChatChangeListener();\n\n      // 注入样式\n      injectStyles();\n\n      // 确保Font Awesome已加载\n      ensureFontAwesomeLoaded();\n\n      // 加载GitHub配置\n      loadGitHubConfig();\n      \n      // 加载LLM配置\n      loadLLMConfig();\n      \n      // 加载样式偏好\n      const savedStyle = loadStylePreference();\n      console.log('Memo: 已加载样式偏好:', savedStyle);\n\n      // 加载自定义颜色配置\n      loadCustomColorConfig();\n      console.log('Memo: 已加载自定义颜色配置');\n\n      // 加载字体配置\n      loadFontPreference();\n      loadCustomFonts();\n      loadAllCustomFonts().then(() => {\n        console.log('Memo: 已加载所有网络字体');\n      }).catch(error => {\n        console.error('Memo: 加载网络字体失败:', error);\n      });\n\n      // 如果没有菜单按钮，创建一个\n      createMemoMenuButton();\n\n      // 页面卸载时清理事件监听器\n      window.addEventListener('beforeunload', () => {\n        removeChatChangeListener();\n        stopMessageObserver();\n      });\n    } catch (error) {\n      console.error('Memo: 初始化失败:', error);\n    }\n  }\n}\n\n// 初始化调用\ninitializeMemo();\n\n// 消息观察器相关函数\nfunction initMessageObserver() {\n  try {\n    // 移除之前的观察器\n    if (messageObserver) {\n      messageObserver.disconnect();\n    }\n\n    // 查找聊天容器\n    const chatContainer = MemoDoc.querySelector('#chat') ||\n      MemoDoc.querySelector('.chat-container') ||\n      MemoDoc.querySelector('[id*=\"chat\"]');\n\n    if (!chatContainer) {\n      console.log('Memo: 未找到聊天容器，稍后重试...');\n      // 5秒后重试\n      setTimeout(() => initMessageObserver(), 5000);\n      return;\n    }\n\n    console.log('Memo: 开始监听消息变化...');\n\n    messageObserver = new MutationObserver((mutations) => {\n      let needsUpdate = false;\n\n      mutations.forEach((mutation) => {\n        if (mutation.type === 'childList') {\n          mutation.addedNodes.forEach((node) => {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n              needsUpdate = true;\n            }\n          });\n        }\n      });\n\n      if (needsUpdate) {\n        // 防抖处理，避免频繁更新\n        clearTimeout(window.memoAnnotationTimeout);\n        window.memoAnnotationTimeout = setTimeout(() => {\n          injectParagraphButtons(chatContainer);\n        }, 300);\n      }\n    });\n\n    messageObserver.observe(chatContainer, {\n      childList: true,\n      subtree: true\n    });\n\n    // 初始化现有消息\n    setTimeout(() => {\n      injectParagraphButtons(chatContainer);\n      // 创建控制面板\n      createControlPanel();\n    }, 1000);\n\n    // 监听窗口大小变化，重新定位控制面板\n    window.addEventListener('resize', () => {\n      if (selectionState.controlPanel) {\n        setTimeout(() => {\n          positionControlPanel();\n        }, 100);\n      }\n    });\n\n  } catch (error) {\n    console.error('Memo: 初始化消息观察器失败:', error);\n  }\n}\n\nfunction injectParagraphButtons(container) {\n  try {\n    // 查找所有消息中的段落\n    const selectors = [\n      '.mes_text p',\n      '.message_text p',\n      '.mes_text div:not(.memo-annotation-btn):not([class*=\"btn\"]):not([class*=\"button\"]), .message_text div:not(.memo-annotation-btn):not([class*=\"btn\"]):not([class*=\"button\"])'\n    ];\n\n    selectors.forEach(selector => {\n      const paragraphs = container.querySelectorAll(selector);\n      paragraphs.forEach((paragraph, index) => {\n        // 检查段落是否有足够的文本内容（排除按钮文本）\n        const textContent = getPureTextContent(paragraph);\n        if (!textContent || textContent.length < 1) {\n          return; // 跳过太短的内容\n        }\n\n        // 检查是否已经有按钮\n        if (!paragraph.querySelector('.memo-annotation-btn')) {\n          createAnnotationButton(paragraph, index);\n        }\n      });\n    });\n\n  } catch (error) {\n    console.error('Memo: 注入段落按钮失败:', error);\n  }\n}\n\nfunction createAnnotationButton(paragraph, index) {\n  try {\n    const button = MemoDoc.createElement('button');\n    button.className = 'memo-annotation-btn';\n    button.title = selectionState.isMultiSelectMode ? '点击选择段落' : '为此段落创建Memo';\n\n    // 根据模式设置按钮内容\n    updateButtonContent(button, paragraph);\n\n    // 绑定点击事件\n    button.addEventListener('click', (e) => {\n      e.stopPropagation();\n      e.preventDefault();\n\n      if (selectionState.isMultiSelectMode) {\n        toggleParagraphSelection(paragraph, button);\n      } else {\n        const paragraphText = getPureTextContent(paragraph);\n        if (paragraphText) {\n          // 单选模式：获取楼层信息并传递\n          const messageId = getMessageId(paragraph);\n          const sourceContext = {\n            type: 'single',\n            messageId: messageId,\n            floorLabel: generateFloorLabel(messageId)\n          };\n          // 单选模式也在最后加上可爱的✎符号\n          openAnnotationMemo(paragraphText + ' ✎', sourceContext);\n        }\n      }\n    });\n\n    // 设置段落为相对定位\n    paragraph.style.position = 'relative';\n\n    // 添加按钮到段落\n    paragraph.appendChild(button);\n\n  } catch (error) {\n    console.error('Memo: 创建按钮失败:', error);\n  }\n}\n\n// 更新按钮内容和样式\nfunction updateButtonContent(button, paragraph) {\n  if (selectionState.isMultiSelectMode) {\n    const isSelected = selectionState.selectedParagraphs.some(p => p.element === paragraph);\n    button.innerHTML = isSelected ? '☑' : '☐';\n    button.classList.toggle('selected', isSelected);\n  } else {\n    button.innerHTML = '✎';\n    button.classList.remove('selected');\n  }\n}\n\nfunction openAnnotationMemo(paragraphText, sourceContext = null) {\n  try {\n    // 确保模态框结构存在\n    ensureModalStructure();\n\n    // 显示模态框\n    modalElement.style.display = 'block';\n\n    // 渲染创建Memo界面，预填充段落内容\n    renderCreateMemoWithParagraph(paragraphText, sourceContext);\n\n    // 监听聊天切换事件\n    setupChatChangeListener();\n\n    // 监听窗口大小变化，重新居中\n    window.addEventListener('resize', centerModal);\n\n    // 居中显示\n    requestAnimationFrame(() => {\n      centerModal();\n    });\n\n  } catch (error) {\n    console.error('Memo: 打开段落Memo失败:', error);\n    toastr.error('打开Memo功能失败，请重试');\n  }\n}\n\n// 停止消息观察器\nfunction stopMessageObserver() {\n  if (messageObserver) {\n    messageObserver.disconnect();\n    messageObserver = null;\n  }\n}\n\n// 分享Memo功能\nfunction shareMemo(memoId) {\n  try {\n    // 确保使用最新的聊天上下文\n    currentChatContext = getCurrentChatContext();\n    let memos = loadMemosFromStorage(currentChatContext);\n    let memo = memos.find(m => m.id === memoId);\n\n    // 如果在当前上下文中找不到，尝试在所有上下文中查找\n    if (!memo) {\n      // 遍历localStorage中所有以memo_开头的键\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && key.startsWith(LOCAL_STORAGE_KEY_PREFIX)) {\n          try {\n            const contextData = localStorage.getItem(key);\n            if (contextData) {\n              const contextMemos = JSON.parse(contextData);\n              const foundMemo = contextMemos.find(m => m.id === memoId);\n              if (foundMemo) {\n                memo = foundMemo;\n                console.log('在其他上下文找到Memo:', key);\n                break;\n              }\n            }\n          } catch (e) {\n            console.error(`解析键 ${key} 的数据时出错:`, e);\n          }\n        }\n      }\n    }\n\n    if (!memo) {\n      toastr.error('Memo不存在！');\n      return;\n    }\n\n    if (memo.type !== 'annotation' || !memo.originalText) {\n      toastr.error('只能分享段落注释！');\n      return;\n    }\n\n    // 直接生成默认样式(长夏)的图片\n    toastr.info('正在生成图片预览...');\n\n    const preferredStyle = loadStylePreference();\n    const preferredFont = loadFontPreference();\n    generateMemoImage(memo, preferredStyle, preferredFont).then(imageDataUrl => {\n      showImagePreviewWithStyleSelector(imageDataUrl, memo, preferredStyle);\n      toastr.success('图片生成成功！');\n    }).catch(error => {\n      console.error('Memo: 生成图片失败:', error);\n      toastr.error('生成图片失败，请重试');\n    });\n\n  } catch (error) {\n    console.error('Memo: 分享Memo失败:', error);\n    toastr.error('分享功能出错，请重试');\n  }\n}\n\n// 显示风格选择界面\nfunction showStyleSelection(memo) {\n  // 设置当前视图状态\n  state.currentView = 'style-selection';\n\n  modalTitleElement.textContent = '选择卡片风格';\n\n  const html = `\n    <div style=\"padding: 20px 0;\">\n      <div style=\"margin-bottom: 20px; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8)); font-size: 14px; text-align: center;\">\n        为\"${escapeHtml(getDisplayTitle(memo))}\"选择分享卡片\n      </div>\n      \n      <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin: 20px 0;\">\n        <!-- 长夏 -->\n        <div class=\"style-option\" data-style=\"summer\" style=\"\n          border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n          border-radius: 12px;\n          padding: 16px;\n          text-align: center;\n          cursor: pointer;\n          transition: all 0.3s ease;\n          background: linear-gradient(135deg, #e8f8e8 0%, #f0fff0 100%);\n        \">\n          <div style=\"\n            width: 100%;\n            height: 80px;\n            border-radius: 8px;\n            margin-bottom: 12px;\n            background: linear-gradient(135deg, #e8f8e8 0%, #f0fff0 20%, #e6ffe6 40%, #d4f8d4 60%, #e8f8e8 80%, #c8f0c8 100%);\n            position: relative;\n          \">\n            <div style=\"\n              position: absolute;\n              top: 8px;\n              left: 8px;\n              font-size: 10px;\n              color: #2d5a2d;\n              font-family: serif;\n            \">预览</div>\n            <div style=\"\n              position: absolute;\n              top: 20px;\n              left: 8px;\n              right: 8px;\n              height: 2px;\n              background: #28a745;\n              width: 30px;\n            \"></div>\n          </div>\n          <h4 style=\"margin: 0 0 8px 0; color: #2d5a2d; font-size: 14px;\">长夏</h4>\n        </div>\n\n        <!-- 如是说 -->\n        <div class=\"style-option\" data-style=\"papper\" style=\"\n          border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n          border-radius: 12px;\n          padding: 16px;\n          text-align: center;\n          cursor: pointer;\n          transition: all 0.3s ease;\n          background: linear-gradient(135deg, #f5f2e8 0%, #f8f5eb 100%);\n        \">\n          <div style=\"\n            width: 100%;\n            height: 80px;\n            border-radius: 8px;\n            margin-bottom: 12px;\n            background: linear-gradient(135deg, #f5f2e8 0%, #f8f5eb 30%, #f2efdf 70%, #f6f3e5 100%);\n            position: relative;\n          \">\n            <div style=\"\n              position: absolute;\n              top: 8px;\n              left: 8px;\n              font-size: 10px;\n              color: #5d4e37;\n              font-family: serif;\n            \">预览</div>\n            <div style=\"\n              position: absolute;\n              top: 20px;\n              left: 8px;\n              right: 8px;\n              height: 2px;\n              background: #2c5aa0;\n              width: 30px;\n            \"></div>\n          </div>\n          <h4 style=\"margin: 0 0 8px 0; color: #5d4e37; font-size: 14px;\">如是说</h4>\n        </div>\n\n        <!-- 棉花糖 -->\n        <div class=\"style-option\" data-style=\"marshmallow\" style=\"\n          border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n          border-radius: 12px;\n          padding: 16px;\n          text-align: center;\n          cursor: pointer;\n          transition: all 0.3s ease;\n          background: linear-gradient(135deg, #f8f9ff 0%, #fff5f0 100%);\n        \">\n          <div style=\"\n            width: 100%;\n            height: 80px;\n            border-radius: 8px;\n            margin-bottom: 12px;\n            background: linear-gradient(135deg, #f8f9ff 0%, #f0f4ff 30%, #fff0f5 70%, #fff5f0 100%);\n            position: relative;\n          \">\n            <div style=\"\n              position: absolute;\n              top: 8px;\n              left: 8px;\n              font-size: 10px;\n              color: #666;\n              font-family: serif;\n            \">预览</div>\n            <div style=\"\n              position: absolute;\n              top: 20px;\n              left: 8px;\n              right: 8px;\n              height: 2px;\n              background: #4a9eff;\n              width: 30px;\n            \"></div>\n          </div>\n          <h4 style=\"margin: 0 0 8px 0; color: #2c3e50; font-size: 14px;\">棉花糖</h4>\n        </div>\n\n        <!-- 朱砂痣 -->\n        <div class=\"style-option\" data-style=\"rose\" style=\"\n          border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n          border-radius: 12px;\n          padding: 16px;\n          text-align: center;\n          cursor: pointer;\n          transition: all 0.3s ease;\n          background: linear-gradient(135deg, #f8e6e6 0%, #fde4e4 100%);\n        \">\n          <div style=\"\n            width: 100%;\n            height: 80px;\n            border-radius: 8px;\n            margin-bottom: 12px;\n            background: linear-gradient(135deg, #f8e6e6 0%, #fce8e8 20%, #f5dede 40%, #f9e0e0 60%, #fde4e4 80%, #f1d0d0 100%);\n            position: relative;\n          \">\n            <div style=\"\n              position: absolute;\n              top: 8px;\n              left: 8px;\n              font-size: 10px;\n              color: #8b4a4a;\n              font-family: serif;\n            \">预览</div>\n            <div style=\"\n              position: absolute;\n              top: 20px;\n              left: 8px;\n              right: 8px;\n              height: 2px;\n              background: #a64545;\n              width: 30px;\n            \"></div>\n          </div>\n          <h4 style=\"margin: 0 0 8px 0; color: #8b4a4a; font-size: 14px;\">朱砂痣</h4>\n        </div>\n\n        <!-- 泥沼中 -->\n        <div class=\"style-option\" data-style=\"drowninlove\" style=\"\n          border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n          border-radius: 12px;\n          padding: 16px;\n          text-align: center;\n          cursor: pointer;\n          transition: all 0.3s ease;\n          background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);\n        \">\n          <div style=\"\n            width: 100%;\n            height: 80px;\n            border-radius: 8px;\n            margin-bottom: 12px;\n            background: linear-gradient(135deg, #2c3e50 0%, #34495e 30%, #1a1a2e 70%, #0f0f23 100%);\n            position: relative;\n          \">\n            <div style=\"\n              position: absolute;\n              top: 8px;\n              left: 8px;\n              font-size: 10px;\n              color: #bbb;\n              font-family: serif;\n            \">预览</div>\n            <div style=\"\n              position: absolute;\n              top: 20px;\n              left: 8px;\n              right: 8px;\n              height: 2px;\n              background: #00d4ff;\n              width: 30px;\n            \"></div>\n          </div>\n          <h4 style=\"margin: 0 0 8px 0; color: #fff; font-size: 14px;\">泥沼中</h4>\n        </div>\n      </div>\n    </div>\n\n    <style>\n      .style-option:hover {\n        transform: translateY(-2px);\n        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);\n        border-color: var(--SmartThemeQuoteColor, #4a9eff) !important;\n      }\n      \n      @media (max-width: 768px) {\n        .style-option {\n          grid-template-columns: 1fr !important;\n        }\n      }\n    </style>\n  `;\n\n  modalBodyElement.innerHTML = html;\n\n  // 绑定风格选择事件\n  const styleOptions = modalBodyElement.querySelectorAll('.style-option');\n  styleOptions.forEach(option => {\n    option.addEventListener('click', () => {\n      const style = option.getAttribute('data-style');\n      generateImageWithStyle(memo, style);\n    });\n  });\n\n  // 渲染底部按钮\n  modalFooterElement.innerHTML = '';\n  modalFooterElement.appendChild(createButton('返回', 'secondary', () => renderMemoList()));\n\n  // 重新居中模态框\n  requestAnimationFrame(() => {\n    centerModal();\n  });\n}\n\n// 使用指定风格生成图片\nfunction generateImageWithStyle(memo, style) {\n  // 显示加载提示\n  toastr.info('正在生成图片...');\n\n  // 生成图片\n  generateMemoImage(memo, style).then(imageDataUrl => {\n    // 显示图片预览\n    showImagePreview(imageDataUrl, memo, style);\n    toastr.success('图片生成成功！');\n  }).catch(error => {\n    console.error('Memo: 生成图片失败:', error);\n    toastr.error('生成图片失败，请重试');\n  });\n}\n\n// 显示图片预览\nfunction showImagePreview(imageDataUrl, memo, style) {\n  // 设置当前视图状态\n  state.currentView = 'preview';\n\n  modalTitleElement.textContent = '图片预览';\n\n  const html = `\n    <div style=\"text-align: center; padding: 20px 0;\">\n      <div style=\"margin-bottom: 20px; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8)); font-size: 14px;\">\n        ${escapeHtml(getDisplayTitle(memo))} - ${style === 'marshmallow' ? '棉花糖 - 粉蓝' :\n      style === 'drowninlove' ? '泥沼中 - 青黑' :\n        style === 'summer' ? '长夏 - 绿色' :\n          style === 'papper' ? '如是说 - 信纸' :\n            style === 'rose' ? '朱砂痣 - 朱红' :\n              style === 'ink' ? '缓缓 - 淡墨' : '未知'\n    }风格\n      </div>\n      <div style=\"max-height: 500px; overflow: auto; border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1)); border-radius: 8px; background: #fff; padding: 10px;\">\n        <img src=\"${imageDataUrl}\" style=\"max-width: 100%; height: auto; border-radius: 4px;\" alt=\"Memo图片\" />\n      </div>\n    </div>\n  `;\n\n  modalBodyElement.innerHTML = html;\n\n  // 渲染底部按钮\n  modalFooterElement.innerHTML = '';\n  modalFooterElement.appendChild(createButton('下载图片', 'primary', () => downloadImage(imageDataUrl, memo, style)));\n  modalFooterElement.appendChild(createButton('重新选择风格', 'secondary', () => showStyleSelection(memo)));\n  modalFooterElement.appendChild(createButton('返回列表', 'secondary', () => renderMemoList()));\n\n  // 重新居中模态框\n  requestAnimationFrame(() => {\n    centerModal();\n  });\n}\n\n// 下载图片\nfunction downloadImage(imageDataUrl, memo, style) {\n  try {\n    // 生成更有意义的文件名\n    const displayTitle = getDisplayTitle(memo);\n    const safeTitle = displayTitle.replace(/[^\\w\\u4e00-\\u9fa5]/g, '_').substring(0, 20);\n    const timestamp = new Date().toISOString().slice(0, 16).replace(/[:\\-]/g, '');\n    const fileName = `memo_usage_report_${timestamp}.png`;\n\n    // 创建下载链接\n    const link = MemoDoc.createElement('a');\n    link.href = imageDataUrl;\n    link.download = fileName;\n\n    // 触发下载\n    MemoDoc.body.appendChild(link);\n    link.click();\n    MemoDoc.body.removeChild(link);\n\n    toastr.success('图片已下载！');\n    \n    // 保存样式偏好\n    saveStylePreference(style);\n  } catch (error) {\n    console.error('Memo: 下载图片失败:', error);\n    toastr.error('下载失败，请重试');\n  }\n}\n\n// 生成Memo图片\nfunction generateMemoImage(memo, style = 'summer', customFont = 'QiushuiShotai') {\n  return new Promise((resolve, reject) => {\n    try {\n      // 定义主题配置\n      const themes = {\n        custom: {\n          name: '自定义配色',\n          background: {\n            colors: [state.customColorConfig.color1, state.customColorConfig.color2]\n          },\n          colors: {\n            userInfo: state.customColorConfig.fontColor,\n            time: state.customColorConfig.fontColor,\n            title: state.customColorConfig.fontColor,\n            accent: state.customColorConfig.fontColor,\n            excerpt: state.customColorConfig.fontColor,\n            notes: state.customColorConfig.fontColor,\n            brand: state.customColorConfig.fontColor,\n            decorativeLine: state.customColorConfig.fontColor,\n            separatorLine: state.customColorConfig.fontColor\n          }\n        },\n        marshmallow: {\n          name: '棉花糖 - 粉蓝',\n          background: {\n            colors: ['#f8f9ff', '#f0f4ff', '#fff0f5', '#fff5f0']\n          },\n          colors: {\n            userInfo: '#666',\n            time: '#999',\n            title: '#2c3e50',\n            accent: '#4a9eff',\n            excerpt: '#34495e',\n            notes: '#555',\n            brand: '#999',\n            decorativeLine: '#4a9eff',\n            separatorLine: '#e0e0e0'\n          }\n        },\n        drowninlove: {\n          name: '泥沼中 - 青黑',\n          background: {\n            colors: ['#000000', '#0a0a0a', '#050505', '#000000']\n          },\n          colors: {\n            userInfo: '#00cccc',\n            time: '#008888',\n            title: '#00ffff',\n            accent: '#00ffff',\n            excerpt: '#00eeee',\n            notes: '#00dddd',\n            brand: '#00aaaa',\n            decorativeLine: '#00ffff',\n            separatorLine: '#003333'\n          }\n        },\n        summer: {\n          name: '长夏 - 绿色',\n          background: {\n            colors: ['#f0fff0', '#e8f8e8', '#d8f0d8', '#c8e8c8']\n          },\n          colors: {\n            userInfo: '#2d5a2d',\n            time: '#5a7a5a',\n            title: '#1e3a1e',\n            accent: '#28a745',\n            excerpt: '#2d5a2d',\n            notes: '#3d6a3d',\n            brand: '#5a7a5a',\n            decorativeLine: '#28a745',\n            separatorLine: '#b8d8b8'\n          }\n        },\n        papper: {\n          name: '如是说 - 信纸',\n          background: {\n            colors: ['#f5f2e8', '#f8f5eb', '#f2efdf', '#f6f3e5']\n          },\n          colors: {\n            userInfo: '#5d4e37',\n            time: '#8b7d6b',\n            title: '#2c5aa0',\n            accent: '#2c5aa0',\n            excerpt: '#2c5aa0',\n            notes: '#4a4a4a',\n            brand: '#8b7d6b',\n            decorativeLine: '#2c5aa0',\n            separatorLine: '#d4c5a9'\n          }\n        },\n        rose: {\n          name: '朱砂痣 - 朱红',\n          background: {\n            colors: ['#fdf5f5', '#f8e6e6', '#f0d0d0', '#e8c0c0']\n          },\n          colors: {\n            userInfo: '#8b4a4a',\n            time: '#a05656',\n            title: '#a64545',\n            accent: '#a64545',\n            excerpt: '#a64545',\n            notes: '#735555',\n            brand: '#a05656',\n            decorativeLine: '#a64545',\n            separatorLine: '#e8c5c5'\n          }\n        },\n        ink: {\n          name: '缓缓 - 淡墨',\n          background: {\n            colors: ['#f8f8f8', '#f0f0f0', '#e8e8e8', '#f5f5f5']\n          },\n          colors: {\n            userInfo: '#2c3e50',\n            time: '#34495e',\n            title: '#1a237e',\n            accent: '#3949ab',\n            excerpt: '#283593',\n            notes: '#1a237e',\n            brand: '#5c6bc0',\n            decorativeLine: '#3949ab',\n            separatorLine: '#bdc3c7'\n          }\n        }\n      };\n\n      const theme = themes[style] || themes.summer;\n\n      const canvas = MemoDoc.createElement('canvas');\n      const ctx = canvas.getContext('2d');\n\n      // 设置画布尺寸（类似手机屏幕比例）\n      const width = 800;\n      // 先计算内容所需的高度\n      const estimatedHeight = calculateContentHeight(ctx, memo, width, customFont);\n      const height = Math.max(250, estimatedHeight + 3); // 最小高度250px，加3px的缓冲\n\n      canvas.width = width;\n      canvas.height = height;\n\n      // 设置画布缩放以获得更清晰的文字\n      const scale = 2;\n      canvas.width = width * scale;\n      canvas.height = height * scale;\n      canvas.style.width = width + 'px';\n      canvas.style.height = height + 'px';\n      ctx.scale(scale, scale);\n\n      // 绘制背景\n      drawBackground(ctx, width, height, theme);\n\n      // 绘制内容\n      drawMemoContent(ctx, memo, width, height, theme, customFont).then(() => {\n        // 返回图片数据\n        resolve(canvas.toDataURL('image/png', 0.9));\n      }).catch(reject);\n\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n\n// 计算内容所需的高度\nfunction calculateContentHeight(ctx, memo, width, customFont) {\n  const padding = 30;\n  const contentWidth = width - padding * 2;\n  let totalHeight = padding + 20; // 初始padding\n\n  // 用户名和角色名\n  totalHeight += 20; // 用户信息行高度\n\n  // 设置字体以准确计算\n  ctx.font = `12px \"${customFont}\", serif`;\n  totalHeight += 15; // 时间行高度\n  totalHeight += 25; // 时间到标题的间距\n\n  // 计算标题高度\n  if (memo.title && memo.title.trim()) {\n    ctx.font = `bold 20px \"${customFont}\", serif`;\n    const titleLines = wrapText(ctx, memo.title.trim(), contentWidth);\n    totalHeight += titleLines.length * 26 + 15;\n  }\n\n  // 装饰线\n  totalHeight += 20;\n\n  // \"摘录\"标签\n  totalHeight += 18;\n\n  // 计算原文高度\n  ctx.font = `18px \"${customFont}\", serif`;\n  const originalLines = wrapText(ctx, memo.originalText, contentWidth - 30);\n  totalHeight += originalLines.length * 24 + 25; // 内容 + 引号空间 + 间距\n\n  // 分隔线\n  totalHeight += 20;\n\n  // 只有当有笔记内容时才计算笔记相关高度\n  if (memo.content && memo.content.trim()) {\n    // \"笔记\"标签\n    totalHeight += 15;\n\n    // 计算注释高度\n    ctx.font = `16px \"${customFont}\", serif`;\n    const contentLines = wrapText(ctx, memo.content, contentWidth);\n    totalHeight += contentLines.length * 22 + 15; // 内容 + 间距（更紧凑）\n\n    // 到底部装饰的间距\n    totalHeight += 8;\n  }\n\n  // 底部装饰\n  totalHeight += 12; // 标语高度\n  totalHeight += 10; // 最终底部间距\n\n  return totalHeight;\n}\n\n// 绘制背景\nfunction drawBackground(ctx, width, height, theme) {\n  // 创建温暖的渐变背景\n  const gradient = ctx.createLinearGradient(0, 0, width, height);\n  const colors = theme.background.colors;\n\n  // 动态添加渐变色，根据颜色数量平均分布\n  colors.forEach((color, index) => {\n    const position = index / (colors.length - 1);\n    gradient.addColorStop(position, color);\n  });\n\n  ctx.fillStyle = gradient;\n  ctx.fillRect(0, 0, width, height);\n}\n\n// 绘制Memo内容\nfunction drawMemoContent(ctx, memo, width, height, theme, customFont) {\n  return new Promise((resolve) => {\n    const padding = 30;\n    const contentWidth = width - padding * 2;\n    let currentY = padding + 20;\n\n    // 设置默认字体和颜色\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'top';\n\n    // 0. 绘制用户名和角色名（左上角）\n    try {\n      let userName = 'User';\n      let charName = 'Character';\n\n      // 尝试使用TavernHelper获取用户名和角色名\n      if (window.TavernHelper && window.TavernHelper.substitudeMacros) {\n        try {\n          const userMacro = window.TavernHelper.substitudeMacros('{{user}}');\n          const charMacro = window.TavernHelper.substitudeMacros('{{char}}');\n\n          if (userMacro && userMacro !== '{{user}}') userName = userMacro;\n          if (charMacro && charMacro !== '{{char}}') charName = charMacro;\n        } catch (e) {\n          // 如果宏替换失败，尝试其他方法\n          charName = getCharacterName();\n        }\n      } else {\n        // 如果没有TavernHelper，使用备用方法\n        charName = getCharacterName();\n      }\n\n      ctx.font = `12px \"${customFont}\", serif`;\n      ctx.fillStyle = theme.colors.userInfo;\n      ctx.textAlign = 'left';\n      ctx.fillText(`${userName} & ${charName}`, padding, currentY);\n\n      currentY += 20;\n    } catch (e) {\n      console.warn('Memo: 获取用户名和角色名失败:', e);\n      currentY += 15; // 如果失败，仍然保留一些空间\n    }\n\n    // 0.5. 绘制楼层信息（如果有的话）\n    if (memo.floorLabel && memo.floorLabel !== '手动创建') {\n      ctx.font = `11px \"${customFont}\", serif`;\n      ctx.fillStyle = theme.colors.userInfo;\n      ctx.textAlign = 'right';\n      ctx.fillText(`来自 ${memo.floorLabel}`, width - padding, currentY - 20);\n    }\n\n    // 1. 绘制时间\n    const timeText = new Date(memo.updatedAt || memo.createdAt).toLocaleString('zh-CN');\n    ctx.font = `12px \"${customFont}\", serif`;\n    ctx.fillStyle = theme.colors.time;\n    ctx.textAlign = 'right';\n    ctx.fillText(timeText, width - padding, currentY);\n\n    currentY += 25;\n\n    // 2. 绘制标题（如果有）\n    ctx.textAlign = 'left';\n    if (memo.title && memo.title.trim()) {\n      ctx.font = `bold 20px \"${customFont}\", serif`;\n      ctx.fillStyle = theme.colors.title;\n\n      const titleLines = wrapText(ctx, memo.title.trim(), contentWidth);\n      titleLines.forEach(line => {\n        if (line.trim() === '') {\n          // 空行也要占位\n          currentY += 26;\n        } else {\n          ctx.fillText(line, padding, currentY);\n          currentY += 26;\n        }\n      });\n\n      currentY += 15;\n    }\n\n    // 3. 绘制装饰线\n    ctx.strokeStyle = theme.colors.decorativeLine;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n    ctx.moveTo(padding, currentY);\n    ctx.lineTo(padding + 40, currentY);\n    ctx.stroke();\n\n    currentY += 20;\n\n    // 4. 绘制原文段落（突出显示）\n    // 添加\"摘录\"标签\n    ctx.font = `14px \"${customFont}\", serif`;\n    ctx.fillStyle = theme.colors.accent;\n    ctx.fillText('摘录', padding, currentY);\n    currentY += 18;\n\n    ctx.font = `18px \"${customFont}\", serif`;\n    ctx.fillStyle = theme.colors.excerpt;\n\n    // 添加引号\n    ctx.font = `bold 24px \"${customFont}\", serif`;\n    ctx.fillStyle = theme.colors.accent;\n    ctx.fillText('\"', padding, currentY);\n\n    currentY += 5;\n\n    // 原文内容\n    ctx.font = `18px \"${customFont}\", serif`;\n    ctx.fillStyle = theme.colors.excerpt;\n\n    const originalLines = wrapText(ctx, memo.originalText, contentWidth - 30);\n    originalLines.forEach(line => {\n      if (line.trim() === '') {\n        // 空行也要占位\n        currentY += 24;\n      } else {\n        ctx.fillText(line, padding + 15, currentY);\n        currentY += 24;\n      }\n    });\n\n    // 结束引号\n    ctx.font = `bold 24px \"${customFont}\", serif`;\n    ctx.fillStyle = theme.colors.accent;\n    ctx.fillText('\"', width - padding - 15, currentY - 24);\n\n    currentY += 20;\n\n    // 5. 绘制分隔线\n    ctx.strokeStyle = theme.colors.separatorLine;\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(padding + 15, currentY);\n    ctx.lineTo(width - padding - 15, currentY);\n    ctx.stroke();\n\n    currentY += 20;\n\n    // 6. 绘制注释内容（只有当有笔记内容时才绘制）\n    if (memo.content && memo.content.trim()) {\n      // 添加\"笔记\"标签\n      ctx.font = `14px \"${customFont}\", serif`;\n      ctx.fillStyle = theme.colors.accent;\n      ctx.fillText('笔记', padding, currentY);\n      currentY += 15;\n\n      ctx.font = `16px \"${customFont}\", serif`;\n      ctx.fillStyle = theme.colors.notes;\n\n      const contentLines = wrapText(ctx, memo.content, contentWidth);\n      contentLines.forEach(line => {\n        if (line.trim() === '') {\n          // 空行也要占位\n          currentY += 22;\n        } else {\n          ctx.fillText(line, padding, currentY);\n          currentY += 22;\n        }\n      });\n\n      // 添加一点间距到底部装饰\n      currentY += 8;\n    }\n\n    // 小标语\n    ctx.font = `12px \"${customFont}\", serif`;\n    ctx.fillStyle = theme.colors.brand;\n    ctx.textAlign = 'center';\n    ctx.fillText('- 来自酒馆使用报告 -', width / 2, currentY + 16);\n\n    // 更新currentY到标语之后，确保有足够的底部间距\n    currentY += 10;\n\n    resolve();\n  });\n}\n\n// 文本换行函数\nfunction wrapText(ctx, text, maxWidth) {\n  // 首先按照用户的换行符分割\n  const userLines = text.split(/\\r?\\n/);\n  const lines = [];\n\n  // 对每一行进行自动换行处理\n  userLines.forEach(userLine => {\n    if (userLine.trim() === '') {\n      // 空行也要保留\n      lines.push('');\n      return;\n    }\n\n    const chars = userLine.split('');\n    let currentLine = '';\n\n    for (let i = 0; i < chars.length; i++) {\n      const char = chars[i];\n      const testLine = currentLine + char;\n      const testWidth = ctx.measureText(testLine).width;\n\n      if (testWidth > maxWidth && currentLine !== '') {\n        lines.push(currentLine);\n        currentLine = char;\n      } else {\n        currentLine = testLine;\n      }\n    }\n\n    if (currentLine !== '') {\n      lines.push(currentLine);\n    }\n  });\n\n  return lines;\n}\n\nfunction clearCurrentChatMemos() {\n  if (!confirm('⚠️警告：此操作将删除当前聊天的所有Memo，且无法恢复！\\n\\n确定要继续吗？')) {\n    return;\n  }\n\n  try {\n    // 确定要使用的聊天上下文 - 优先使用手动选择的上下文\n    const clearContext = state.selectedChatContext || getCurrentChatContext();\n    if (!clearContext) {\n      toastr.error('无法获取当前聊天信息！');\n      return;\n    }\n\n    // 获取当前聊天的存储键\n    const storageKey = getStorageKey(clearContext);\n\n    // 获取当前聊天的Memo数量\n    const currentMemos = loadMemosFromStorage(clearContext);\n    const memoCount = currentMemos.length;\n\n    // 删除当前聊天的Memo数据\n    localStorage.removeItem(storageKey);\n\n    toastr.success(`已清空当前聊天的Memo！共删除了 ${memoCount} 条Memo。`);\n\n    // 刷新当前显示\n    renderMemoList();\n  } catch (error) {\n    console.error('Memo: 清空当前聊天Memo失败:', error);\n    toastr.error('清空操作失败，请重试！');\n  }\n}\n\n// 绑定按钮事件，只有点击按钮时才初始化memo系统\neventOnButton('显示Memo', function () {\n  console.log('显示memo按钮被点击');\n\n  // 启动消息观察器，显示小铅笔按钮\n  initMessageObserver();\n\n  // 如果控制面板不存在，创建它；如果存在，重新定位\n  if (!selectionState.controlPanel) {\n    createControlPanel();\n  } else {\n    positionControlPanel();\n  }\n\n  // 显示成功提示（如果toastr可用）\n  if (typeof toastr !== 'undefined') {\n    toastr.success('Memo已开启');\n  }\n});\n\n// 停止memo系统的函数\nfunction stopMemo() {\n  try {\n    console.log('正在隐藏段落注释按钮...');\n\n    // 1. 退出多选模式并清理状态\n    if (selectionState.isMultiSelectMode) {\n      selectionState.isMultiSelectMode = false;\n      clearAllSelections();\n    }\n\n    // 2. 移除控制面板\n    removeControlPanel();\n\n    // 3. 移除多选模式样式\n    const chatContainer = MemoDoc.querySelector('#chat') ||\n      MemoDoc.querySelector('.chat-container') ||\n      MemoDoc.querySelector('[id*=\"chat\"]');\n    if (chatContainer) {\n      chatContainer.classList.remove('memo-multi-select-mode');\n    }\n\n    // 4. 停止消息观察器（不再监听新消息并添加按钮）\n    stopMessageObserver();\n\n    // 5. 移除所有现有的段落按钮\n    const annotationButtons = MemoDoc.querySelectorAll('.memo-annotation-btn');\n    annotationButtons.forEach(button => {\n      if (button.parentNode) {\n        button.parentNode.removeChild(button);\n      }\n    });\n\n    // 6. 清理段落选中样式\n    const selectedParagraphs = MemoDoc.querySelectorAll('.memo-paragraph-selected');\n    selectedParagraphs.forEach(paragraph => {\n      paragraph.classList.remove('memo-paragraph-selected');\n    });\n\n    // 7. 清理窗口事件监听器\n    window.removeEventListener('resize', positionControlPanel);\n\n    console.log('段落注释按钮已隐藏');\n\n    // 显示成功提示（如果toastr可用）\n    if (typeof toastr !== 'undefined') {\n      toastr.success('Memo已关闭');\n    }\n\n  } catch (error) {\n    console.error('Memo: 隐藏段落按钮时出错:', error);\n    if (typeof toastr !== 'undefined') {\n      toastr.error('关闭段落注释时出现错误');\n    }\n  }\n}\n\n// 创建多选控制面板\nfunction createControlPanel() {\n  if (selectionState.controlPanel) {\n    console.log('Memo: 控制面板已存在，跳过创建');\n    return; // 避免重复创建\n  }\n\n  try {\n    console.log('Memo: 开始创建控制面板...');\n\n    const panel = MemoDoc.createElement('div');\n    panel.className = 'memo-control-panel';\n    panel.innerHTML = `\n      <button id=\"memoToggleMultiSelect\" class=\"memo-control-btn\">开启多选</button>\n      <button id=\"memoCloseButton\" class=\"memo-control-btn secondary\">关闭Memo</button>\n      <button id=\"memoSelectAllBetween\" class=\"memo-control-btn\" style=\"display: none;\">全选中间</button>\n      <button id=\"memoCompleteSelection\" class=\"memo-control-btn secondary\" style=\"display: none;\">完成选择 (0)</button>\n    `;\n\n    // 添加到文档\n    MemoDoc.body.appendChild(panel);\n    selectionState.controlPanel = panel;\n\n    console.log('Memo: 控制面板DOM元素已创建并添加到页面');\n\n    // 动态定位面板\n    positionControlPanel();\n\n    // 绑定事件\n    const toggleBtn = panel.querySelector('#memoToggleMultiSelect');\n    const closeBtn = panel.querySelector('#memoCloseButton');\n    const selectAllBtn = panel.querySelector('#memoSelectAllBetween');\n    const completeBtn = panel.querySelector('#memoCompleteSelection');\n\n    if (toggleBtn && closeBtn && selectAllBtn && completeBtn) {\n      toggleBtn.addEventListener('click', toggleMultiSelectMode);\n      closeBtn.addEventListener('click', function() {\n        console.log('关闭memo按钮被点击');\n        stopMemo();\n      });\n      selectAllBtn.addEventListener('click', selectAllBetween);\n      completeBtn.addEventListener('click', completeSelection);\n      console.log('Memo: 控制面板事件绑定成功');\n    } else {\n      console.error('Memo: 控制面板按钮元素未找到！');\n    }\n\n    // 强制显示面板，防止被其他CSS覆盖\n    setTimeout(() => {\n      if (selectionState.controlPanel) {\n        // 查找参照元素 - SillyTavern的输入框\n        const sendForm = MemoDoc.querySelector('#send_form');\n\n        if (sendForm) {\n          const sendFormRect = sendForm.getBoundingClientRect();\n\n          // 计算控制面板位置：在输入框上方15px，水平居中，更贴近输入框\n          const panelWidth = 340; // 增加宽度以适应新增的全选按钮\n          const leftPosition = sendFormRect.left + (sendFormRect.width - panelWidth) / 2;\n          const topPosition = sendFormRect.top - 60; // 在输入框上方60px（面板高度约45px + 15px间距）\n\n          console.log('Memo: 参照元素信息:', {\n            sendFormRect: {\n              top: sendFormRect.top,\n              left: sendFormRect.left,\n              width: sendFormRect.width,\n              height: sendFormRect.height\n            },\n            计算位置: {\n              leftPosition,\n              topPosition,\n              panelWidth,\n              间距: '15px'\n            }\n          });\n\n          // 使用相对定位\n          selectionState.controlPanel.style.cssText = `\n            position: fixed !important;\n            top: ${topPosition}px !important;\n            left: ${leftPosition}px !important;\n            width: ${panelWidth}px !important;\n            margin: 0 !important;\n            transform: none !important;\n            z-index: 9999 !important;\n            display: flex !important;\n            visibility: visible !important;\n            opacity: 1 !important;\n            background: var(--SmartThemeBlurTintColor, rgba(0, 0, 0, 0.4)) !important;\n            color: var(--SmartThemeBodyColor, #e0e0e0) !important;\n            padding: 6px 10px !important;\n            border-radius: 12px !important;\n            border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.15)) !important;\n            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2) !important;\n            backdrop-filter: blur(16px) !important;\n            min-height: 40px !important;\n            gap: 6px !important;\n            align-items: center !important;\n            justify-content: center !important;\n            font-size: 12px !important;\n            font-weight: 500 !important;\n          `;\n\n        } else {\n          console.warn('Memo: 未找到send_form元素，使用备用定位');\n\n          // 备用方案：尝试查找其他已知元素\n          const altElements = [\n            '#send_textarea',\n            '#rightSendForm',\n            '#leftSendForm',\n            '#extensionsMenuButton'\n          ];\n\n          let referenceElement = null;\n          for (const selector of altElements) {\n            referenceElement = MemoDoc.querySelector(selector);\n            if (referenceElement) {\n              console.log(`Memo: 找到备用参照元素: ${selector}`);\n              break;\n            }\n          }\n\n          if (referenceElement) {\n            const refRect = referenceElement.getBoundingClientRect();\n            const panelWidth = 340; // 与主方案保持一致，增加宽度以适应全选按钮\n            const leftPosition = Math.max(10, refRect.left + (refRect.width - panelWidth) / 2);\n            const topPosition = refRect.top - 60; // 改为60px，更贴近参照元素\n\n            selectionState.controlPanel.style.cssText = `\n              position: fixed !important;\n              top: ${topPosition}px !important;\n              left: ${leftPosition}px !important;\n              width: ${panelWidth}px !important;\n              z-index: 9999 !important;\n              display: flex !important;\n              visibility: visible !important;\n              opacity: 1 !important;\n              background: var(--SmartThemeBlurTintColor, rgba(0, 0, 0, 0.4)) !important;\n              color: var(--SmartThemeBodyColor, #e0e0e0) !important;\n              padding: 6px 10px !important;\n              border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.15)) !important;\n              border-radius: 12px !important;\n              box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2) !important;\n              backdrop-filter: blur(16px) !important;\n              min-height: 40px !important;\n              gap: 6px !important;\n              align-items: center !important;\n              justify-content: center !important;\n              font-size: 12px !important;\n              font-weight: 500 !important;\n            `;\n\n            console.log('Memo: 使用备用元素定位，主题色样式');\n          } else {\n            console.error('Memo: 所有参照元素都未找到，使用屏幕中央');\n            // 最终备用方案：屏幕中央\n            selectionState.controlPanel.style.cssText = `\n              position: fixed !important;\n              top: 50% !important;\n              left: 50% !important;\n              width: 340px !important;\n              height: 80px !important;\n              margin-left: -170px !important;\n              margin-top: -40px !important;\n              z-index: 9999 !important;\n              display: flex !important;\n              visibility: visible !important;\n              opacity: 1 !important;\n              background: red !important;\n              color: white !important;\n              padding: 20px !important;\n              border: 5px solid lime !important;\n              border-radius: 10px !important;\n              align-items: center !important;\n              justify-content: center !important;\n              text-align: center !important;\n            `;\n          }\n        }\n\n        // 检查最终结果\n        setTimeout(() => {\n          const finalRect = selectionState.controlPanel.getBoundingClientRect();\n          console.log('Memo: 控制面板最终位置:', {\n            top: finalRect.top,\n            left: finalRect.left,\n            width: finalRect.width,\n            height: finalRect.height,\n            visible: finalRect.width > 0 && finalRect.height > 0 && finalRect.top >= 0 && finalRect.left >= 0,\n            在视口内: finalRect.top >= 0 && finalRect.left >= 0 && finalRect.bottom <= window.innerHeight && finalRect.right <= window.innerWidth\n          });\n        }, 200);\n\n        console.log('Memo: 控制面板已相对于输入框定位');\n      } else {\n        console.error('Memo: selectionState.controlPanel 为 null');\n      }\n    }, 100);\n\n  } catch (error) {\n    console.error('Memo: 创建控制面板失败:', error);\n  }\n}\n\n// 动态定位控制面板\nfunction positionControlPanel() {\n  if (!selectionState.controlPanel) return;\n\n  try {\n    // 使用最简单的CSS定位，避免复杂计算\n    selectionState.controlPanel.style.cssText = `\n      position: fixed !important;\n      bottom: 100px !important;\n      left: 50% !important;\n      width: 340px !important;\n      margin-left: -170px !important;\n      transform: none !important;\n      z-index: 9999 !important;\n      display: flex !important;\n      visibility: visible !important;\n      opacity: 1 !important;\n      background: var(--SmartThemeBlurTintColor, rgba(0, 0, 0, 0.4)) !important;\n      color: var(--SmartThemeBodyColor, #e0e0e0) !important;\n      padding: 6px 10px !important;\n      border-radius: 12px !important;\n      border: none !important;\n      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2) !important;\n      backdrop-filter: blur(16px) !important;\n      min-height: 40px !important;\n      gap: 6px !important;\n      animation: none !important;\n      transition: none !important;\n      top: auto !important;\n      pointer-events: auto !important;\n      align-items: center !important;\n      justify-content: center !important;\n      font-size: 12px !important;\n      font-weight: 500 !important;\n    `;\n\n    console.log('Memo: 控制面板使用简化定位');\n\n  } catch (error) {\n    console.error('Memo: 定位控制面板时出错:', error);\n  }\n}\n\n// 移除控制面板\nfunction removeControlPanel() {\n  if (selectionState.controlPanel && selectionState.controlPanel.parentNode) {\n    selectionState.controlPanel.parentNode.removeChild(selectionState.controlPanel);\n    selectionState.controlPanel = null;\n  }\n}\n\n// 切换多选模式\nfunction toggleMultiSelectMode() {\n  selectionState.isMultiSelectMode = !selectionState.isMultiSelectMode;\n\n  // 更新聊天容器样式\n  const chatContainer = MemoDoc.querySelector('#chat') ||\n    MemoDoc.querySelector('.chat-container') ||\n    MemoDoc.querySelector('[id*=\"chat\"]');\n\n  if (chatContainer) {\n    chatContainer.classList.toggle('memo-multi-select-mode', selectionState.isMultiSelectMode);\n  }\n\n  // 更新控制面板按钮\n  const toggleBtn = selectionState.controlPanel?.querySelector('#memoToggleMultiSelect');\n  const closeBtn = selectionState.controlPanel?.querySelector('#memoCloseButton');\n  const selectAllBtn = selectionState.controlPanel?.querySelector('#memoSelectAllBetween');\n  const completeBtn = selectionState.controlPanel?.querySelector('#memoCompleteSelection');\n\n  if (toggleBtn && closeBtn && selectAllBtn && completeBtn) {\n    if (selectionState.isMultiSelectMode) {\n      toggleBtn.textContent = '退出多选';\n      closeBtn.style.display = 'none'; // 多选模式下隐藏关闭按钮\n      completeBtn.style.display = 'block';\n      // 全选按钮暂时隐藏，由updateSelectAllButton函数控制显示\n      selectAllBtn.style.display = 'none';\n    } else {\n      toggleBtn.textContent = '开启多选';\n      closeBtn.style.display = 'block'; // 普通模式下显示关闭按钮\n      selectAllBtn.style.display = 'none';\n      completeBtn.style.display = 'none';\n      // 清空选择\n      clearAllSelections();\n    }\n  }\n\n  // 更新所有现有的段落按钮\n  updateAllAnnotationButtons();\n  \n  // 更新全选按钮状态\n  if (selectionState.isMultiSelectMode) {\n    updateSelectAllButton();\n  }\n}\n\n// 切换段落选择状态\nfunction toggleParagraphSelection(paragraph, button) {\n  const paragraphText = getPureTextContent(paragraph);\n  if (!paragraphText) return;\n\n  // 检查是否已选中\n  const existingIndex = selectionState.selectedParagraphs.findIndex(p => p.element === paragraph);\n\n  if (existingIndex >= 0) {\n    // 取消选择\n    selectionState.selectedParagraphs.splice(existingIndex, 1);\n    paragraph.classList.remove('memo-paragraph-selected');\n  } else {\n    // 添加选择\n    const messageId = getMessageId(paragraph);\n\n    selectionState.selectedParagraphs.push({\n      element: paragraph,\n      text: paragraphText,\n      messageId: messageId,\n      timestamp: Date.now()\n    });\n    paragraph.classList.add('memo-paragraph-selected');\n  }\n\n  // 更新按钮样式\n  updateButtonContent(button, paragraph);\n\n  // 更新完成选择按钮\n  updateCompleteButton();\n}\n\n// 更新所有段落按钮\nfunction updateAllAnnotationButtons() {\n  const buttons = MemoDoc.querySelectorAll('.memo-annotation-btn');\n  buttons.forEach(button => {\n    const paragraph = button.parentElement;\n    if (paragraph) {\n      updateButtonContent(button, paragraph);\n    }\n  });\n}\n\n// 更新完成选择按钮\nfunction updateCompleteButton() {\n  const completeBtn = selectionState.controlPanel?.querySelector('#memoCompleteSelection');\n  if (completeBtn) {\n    const count = selectionState.selectedParagraphs.length;\n    completeBtn.textContent = `完成选择 (${count})`;\n\n    if (count === 0) {\n      // 没有选择时：暗淡且不可点击\n      completeBtn.classList.add('secondary');\n      completeBtn.disabled = true;\n    } else {\n      // 有选择时：高亮且可点击\n      completeBtn.classList.remove('secondary');\n      completeBtn.disabled = false;\n    }\n  }\n  \n  // 同时更新全选按钮状态\n  updateSelectAllButton();\n}\n\n// 清空所有选择\nfunction clearAllSelections() {\n  selectionState.selectedParagraphs.forEach(item => {\n    item.element.classList.remove('memo-paragraph-selected');\n  });\n  selectionState.selectedParagraphs = [];\n  updateAllAnnotationButtons();\n  updateCompleteButton();\n}\n\n// 完成选择\nfunction completeSelection() {\n  if (selectionState.selectedParagraphs.length === 0) {\n    if (typeof toastr !== 'undefined') {\n      toastr.warning('请先选择要创建Memo的段落');\n    }\n    return;\n  }\n\n  // 按DOM顺序排序选中的段落\n  const sortedParagraphs = sortParagraphsByDOMOrder(selectionState.selectedParagraphs);\n\n  // 合并文本，在最后加上可爱的✎符号\n  const combinedText = sortedParagraphs.map(item => item.text).join('\\n\\n') + ' ✎';\n\n  // 计算楼层信息\n  const messageIds = sortedParagraphs\n    .map(p => p.messageId)\n    .filter(id => id !== null && id !== undefined);\n\n  let messageId = null;\n  let floorLabel = '未知楼层';\n\n  if (messageIds.length > 0) {\n    const uniqueMessageIds = [...new Set(messageIds)];\n    if (uniqueMessageIds.length === 1) {\n      // 同楼层\n      messageId = uniqueMessageIds[0];\n      floorLabel = generateFloorLabel(messageId);\n    } else {\n      // 跨楼层\n      messageId = '-';\n      floorLabel = '跨楼层';\n    }\n  }\n\n  const sourceContext = {\n    type: 'multi',\n    messageId: messageId,\n    floorLabel: floorLabel,\n    selectedParagraphs: sortedParagraphs\n  };\n\n  // 退出多选模式\n  toggleMultiSelectMode();\n\n  // 打开创建Memo界面\n  openAnnotationMemo(combinedText, sourceContext);\n}\n\n// 按DOM顺序排序段落\nfunction sortParagraphsByDOMOrder(paragraphs) {\n  return paragraphs.sort((a, b) => {\n    const position = a.element.compareDocumentPosition(b.element);\n    if (position & Node.DOCUMENT_POSITION_FOLLOWING) {\n      return -1; // a在b前面\n    } else if (position & Node.DOCUMENT_POSITION_PRECEDING) {\n      return 1;  // a在b后面\n    }\n    return 0; // 相同位置\n  });\n}\n\n// 获取段落所属的消息ID（楼层号）\nfunction getMessageId(paragraph) {\n  try {\n    // 查找段落所属的消息容器（.mes是SillyTavern的标准消息容器）\n    const messageElement = paragraph.closest('.mes');\n    if (messageElement) {\n      // 获取mesid属性，这就是message_id（楼层号）\n      const messageId = messageElement.getAttribute('mesid');\n      if (messageId) {\n        return parseInt(messageId);\n      }\n    }\n\n    // 备用方法：查找其他可能的消息容器\n    const altMessageElement = paragraph.closest('[mesid], [data-message-id], [id*=\"mes_\"]');\n    if (altMessageElement) {\n      const mesid = altMessageElement.getAttribute('mesid') ||\n        altMessageElement.getAttribute('data-message-id') ||\n        altMessageElement.id.replace(/^mes_/, '');\n      if (mesid) {\n        return parseInt(mesid);\n      }\n    }\n\n    return null;\n  } catch (e) {\n    console.warn('Memo: 获取消息ID失败:', e);\n    return null;\n  }\n}\n\n// 生成楼层显示标签\nfunction generateFloorLabel(messageId) {\n  if (messageId === null || messageId === undefined) {\n    return '未知楼层';\n  }\n  if (messageId === '-') {\n    return '跨楼层';\n  }\n  return `#${messageId}楼`;\n}\n\n// 获取段落的纯净文本内容（排除按钮元素）\nfunction getPureTextContent(paragraph) {\n  // 克隆段落元素，避免影响原始DOM\n  const clonedParagraph = paragraph.cloneNode(true);\n\n  // 移除克隆中的所有按钮元素\n  const buttons = clonedParagraph.querySelectorAll('.memo-annotation-btn');\n  buttons.forEach(button => {\n    button.remove();\n  });\n\n  // 返回纯净的文本内容\n  return clonedParagraph.textContent?.trim() || '';\n}\n\n// 显示带样式选择器的图片预览\n\nfunction showImagePreviewWithStyleSelector(imageDataUrl, memo, currentStyle) {\n  // 设置当前视图状态\n  state.currentView = 'preview-with-selector';\n\n  modalTitleElement.textContent = '分享图片';\n\n  // 样式选项定义\n  const styleOptions = [\n    { value: 'summer', name: '长夏', description: '绿色' },\n    { value: 'papper', name: '如是说', description: '信纸' },\n    { value: 'marshmallow', name: '棉花糖', description: '粉蓝' },\n    { value: 'rose', name: '朱砂痣', description: '朱红' },\n    { value: 'drowninlove', name: '泥沼中', description: '青黑' },\n    { value: 'ink', name: '缓缓', description: '淡墨' },\n    { value: 'custom', name: '自定义配色', description: '个性化' }\n  ];\n\n  // 创建字体选项列表 - 只保留默认字体和已加载的网络字体\n  const fontOptions = [\n    { value: 'QiushuiShotai', name: '秋水书体', description: '默认' }\n  ];\n  \n  // 添加已加载的网络字体\n  for (const fontName of state.fontConfig.loadedFonts) {\n    if (fontName !== 'QiushuiShotai') {\n      fontOptions.push({\n        value: fontName,\n        name: fontName,\n        description: '网络字体'\n      });\n    }\n  }\n\n  const html = `\n    <div style=\"padding: 0 0 20px 0;\">\n      <!-- 样式和字体选择器 -->\n      <div style=\"margin-bottom: 20px; display: flex; flex-direction: column; gap: 16px;\">\n        <!-- 样式选择器行 -->\n        <div style=\"display: flex; align-items: center; gap: 12px; flex-wrap: wrap;\">\n          <label style=\"color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8)); font-size: 14px; font-weight: 500; min-width: 80px;\">\n            卡片样式：\n          </label>\n          <select id=\"reportStyleSelector\" style=\"\n            padding: 8px 12px;\n            border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n            border-radius: 8px;\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n            color: var(--SmartThemeBodyColor, #ffffff);\n            font-size: 14px;\n            cursor: pointer;\n            transition: all 0.3s ease;\n            min-width: 160px;\n            appearance: none;\n            -webkit-appearance: none;\n            -moz-appearance: none;\n            background-image: url(\\\"data:image/svg+xml;charset=UTF-8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6,9 12,15 18,9'></polyline></svg>\\\");\n            background-repeat: no-repeat;\n            background-position: right 8px center;\n            background-size: 16px;\n            padding-right: 32px;\n          \">\n            <option value=\"summer\" ${currentStyle === 'summer' ? 'selected' : ''}>长夏 - 绿色</option>\n            <option value=\"marshmallow\" ${currentStyle === 'marshmallow' ? 'selected' : ''}>棉花糖 - 粉蓝</option>\n            <option value=\"drowninlove\" ${currentStyle === 'drowninlove' ? 'selected' : ''}>泥沼中 - 青黑</option> \n            <option value=\"papper\" ${currentStyle === 'papper' ? 'selected' : ''}>如是说 - 信纸</option>\n            <option value=\"rose\" ${currentStyle === 'rose' ? 'selected' : ''}>朱砂痣 - 朱红</option>\n            <option value=\"ink\" ${currentStyle === 'ink' ? 'selected' : ''}>缓缓 - 淡墨</option>\n            <option value=\"custom\" ${currentStyle === 'custom' ? 'selected' : ''}>自定义配色</option>\n          </select>\n        </div>\n        \n        <!-- 字体选择器行 -->\n        <div style=\"display: flex; align-items: center; gap: 12px; flex-wrap: wrap;\">\n          <label style=\"color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8)); font-size: 14px; font-weight: 500; min-width: 80px;\">\n            字体选择：\n          </label>\n          <select id=\"reportFontSelector\" style=\"\n            padding: 8px 12px;\n            border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n            border-radius: 8px;\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n            color: var(--SmartThemeBodyColor, #ffffff);\n            font-size: 14px;\n            cursor: pointer;\n            transition: all 0.3s ease;\n            min-width: 160px;\n            appearance: none;\n            -webkit-appearance: none;\n            -moz-appearance: none;\n            background-image: url(\\\"data:image/svg+xml;charset=UTF-8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6,9 12,15 18,9'></polyline></svg>\\\");\n            background-repeat: no-repeat;\n            background-position: right 8px center;\n            background-size: 16px;\n            padding-right: 32px;\n          \">\n            ${fontOptions.map(option => `\n              <option value=\"${option.value}\" ${option.value === state.fontConfig.currentFont ? 'selected' : ''}>\n                ${option.name} - ${option.description}\n              </option>\n            `).join('')}\n          </select>\n        </div>\n        \n        <!-- CSS字体URL输入行 -->\n        <div class=\"memo-form-group\">\n          <label class=\"memo-form-label\">加载网络字体：</label>\n          <div style=\"display: flex; align-items: center; gap: 12px; flex-wrap: wrap;\">\n            <input type=\"text\" id=\"fontUrlInput\" placeholder=\"输入CSS字体URL或@import链接...\" style=\"\n              flex: 1;\n              min-width: 300px;\n              padding: 8px 12px;\n              border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n              border-radius: 6px;\n              background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n              color: var(--SmartThemeBodyColor, #ffffff);\n              font-size: 14px;\n              transition: all 0.3s ease;\n            \" />\n            \n            <button id=\"loadFontUrlBtn\" style=\"\n              padding: 8px 16px;\n              background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.7));\n              color: var(--SmartThemeBodyColor, #ffffff);\n              border: 1px solid var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.4));\n              border-radius: 6px;\n              cursor: pointer;\n              font-size: 14px;\n              font-weight: 500;\n              transition: all 0.2s ease;\n              box-shadow: 0 2px 8px rgba(74, 158, 255, 0.15);\n              white-space: nowrap;\n            \">\n              <i class=\"fas fa-link\" style=\"margin-right: 6px; font-size: 12px;\"></i>\n              加载字体\n            </button>\n          </div>\n        </div>\n        \n        <!-- 重新生成按钮 -->\n        <div style=\"display: flex; justify-content: center; margin-top: 8px;\">\n          <button id=\"regenerateImageBtn\" class=\"memo-button secondary\" style=\"min-width: 140px;\">\n            重新生成Memo\n          </button>\n        </div>\n        \n        <!-- 自定义配色配置区域 -->\n        <div id=\"customColorConfigContainer\" style=\"\n          display: none;\n          margin-top: 16px;\n          padding: 16px;\n          border: 2px solid var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2));\n          border-radius: 8px;\n          background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n        \">\n          <h4 style=\"margin: 0 0 12px 0; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.9)); font-size: 14px;\">\n            自定义配色设置\n          </h4>\n          \n          <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;\">\n            <div>\n              <label style=\"display: block; margin-bottom: 4px; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8)); font-size: 12px;\">\n                背景色1（左上）\n              </label>\n              <input type=\"color\" id=\"customColor1\" value=\"${state.customColorConfig.color1}\" style=\"\n                width: 100%;\n                height: 36px;\n                border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                border-radius: 4px;\n                background: transparent;\n                cursor: pointer;\n              \" />\n            </div>\n            <div>\n              <label style=\"display: block; margin-bottom: 4px; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8)); font-size: 12px;\">\n                背景色2（右下）\n              </label>\n              <input type=\"color\" id=\"customColor2\" value=\"${state.customColorConfig.color2}\" style=\"\n                width: 100%;\n                height: 36px;\n                border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                border-radius: 4px;\n                background: transparent;\n                cursor: pointer;\n              \" />\n            </div>\n          </div>\n          \n          <div>\n            <label style=\"display: block; margin-bottom: 4px; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8)); font-size: 12px;\">\n              字体颜色\n            </label>\n            <input type=\"color\" id=\"customFontColor\" value=\"${state.customColorConfig.fontColor}\" style=\"\n              width: 100%;\n              height: 36px;\n              border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n              border-radius: 4px;\n              background: transparent;\n              cursor: pointer;\n            \" />\n          </div>\n          \n          <div style=\"margin-top: 12px; text-align: center;\">\n            <button id=\"applyCustomColorsBtn\" style=\"\n              padding: 6px 16px;\n              background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.7));\n              color: var(--SmartThemeBodyColor, #ffffff);\n              border: 1px solid var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.4));\n              border-radius: 4px;\n              cursor: pointer;\n              font-size: 12px;\n              font-weight: 500;\n            \">\n              应用配色\n            </button>\n          </div>\n        </div>\n      </div>\n      \n      <!-- 图片预览区域 -->\n      <div id=\"imagePreviewContainer\" style=\"\n        text-align: center;\n        max-height: 500px; \n        overflow: auto; \n        border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1)); \n        border-radius: 8px; \n        background: #fff; \n        padding: 10px;\n        position: relative;\n      \">\n        <img id=\"previewImage\" src=\"${imageDataUrl}\" style=\"max-width: 100%; height: auto; border-radius: 4px;\" alt=\"Memo图片\" />\n        \n        <!-- 加载指示器 -->\n        <div id=\"imageLoadingIndicator\" style=\"\n          display: none;\n          position: absolute;\n          top: 50%;\n          left: 50%;\n          transform: translate(-50%, -50%);\n          background: rgba(0, 0, 0, 0.7);\n          color: white;\n          padding: 10px 20px;\n          border-radius: 8px;\n          font-size: 14px;\n        \">\n          正在生成新图片...\n        </div>\n      </div>\n    </div>\n  `;\n\n  modalBodyElement.innerHTML = html;\n\n  // 绑定样式选择器事件\n  const styleSelector = modalBodyElement.querySelector('#reportStyleSelector');\n  const fontSelector = modalBodyElement.querySelector('#reportFontSelector');\n  const previewImage = modalBodyElement.querySelector('#previewImage');\n  const loadingIndicator = modalBodyElement.querySelector('#imageLoadingIndicator');\n\n  // 设置字体选择器样式\n  addSelectFocusStyles('#reportStyleSelector');\n  addSelectFocusStyles('#reportFontSelector');\n\n  // 自动选择当前样式和字体\n  const savedStyle = loadStylePreference();\n  const savedFont = loadFontPreference();\n  const targetStyle = currentStyle || savedStyle;\n  const targetFont = savedFont || 'QiushuiShotai';\n  \n  styleSelector.value = targetStyle;\n  fontSelector.value = targetFont;\n\n  // 样式选择器事件\n  styleSelector.addEventListener('change', (e) => {\n    const newStyle = e.target.value;\n    \n    // 显示或隐藏自定义配色配置\n    const customColorContainer = modalBodyElement.querySelector('#customColorConfigContainer');\n    if (customColorContainer) {\n      if (newStyle === 'custom') {\n        customColorContainer.style.display = 'block';\n      } else {\n        customColorContainer.style.display = 'none';\n      }\n    }\n    \n    if (newStyle === currentStyle) return;\n\n    regenerateImageWithNewSettings(memo, newStyle, state.fontConfig.currentFont, previewImage, loadingIndicator, styleSelector, fontSelector);\n  });\n\n  // 字体选择器事件\n  fontSelector.addEventListener('change', (e) => {\n    const newFont = e.target.value;\n    saveFontPreference(newFont);\n    \n    const currentStyleValue = styleSelector.value;\n    regenerateImageWithNewSettings(memo, currentStyleValue, newFont, previewImage, loadingIndicator, styleSelector, fontSelector);\n  });\n\n  // 重新生成按钮事件\n  const regenerateBtn = modalBodyElement.querySelector('#regenerateImageBtn');\n  if (regenerateBtn) {\n    regenerateBtn.addEventListener('click', () => {\n      const selectedStyle = styleSelector.value;\n      const selectedFont = fontSelector.value;\n      regenerateImageWithNewSettings(memo, selectedStyle, selectedFont, previewImage, loadingIndicator, styleSelector, fontSelector);\n    });\n  }\n\n  // 自定义配色相关事件\n  const customColorContainer = modalBodyElement.querySelector('#customColorConfigContainer');\n  const customColor1 = modalBodyElement.querySelector('#customColor1');\n  const customColor2 = modalBodyElement.querySelector('#customColor2');\n  const customFontColor = modalBodyElement.querySelector('#customFontColor');\n  const applyCustomColorsBtn = modalBodyElement.querySelector('#applyCustomColorsBtn');\n\n  // 初始化自定义配色显示状态\n  if (customColorContainer && styleSelector.value === 'custom') {\n    customColorContainer.style.display = 'block';\n  }\n\n  // 应用自定义配色按钮事件\n  if (applyCustomColorsBtn && customColor1 && customColor2 && customFontColor) {\n    applyCustomColorsBtn.addEventListener('click', () => {\n      // 更新自定义配色配置\n      state.customColorConfig.color1 = customColor1.value;\n      state.customColorConfig.color2 = customColor2.value;\n      state.customColorConfig.fontColor = customFontColor.value;\n      \n      // 保存配置\n      saveCustomColorConfig(state.customColorConfig);\n      \n      // 如果当前选择的是自定义配色，重新生成图片\n      if (styleSelector.value === 'custom') {\n        const selectedFont = fontSelector.value;\n        regenerateImageWithNewSettings(memo, 'custom', selectedFont, previewImage, loadingIndicator, styleSelector, fontSelector);\n      }\n      \n      toastr.success('自定义配色已应用！');\n    });\n  }\n\n  // 渲染底部按钮\n  modalFooterElement.innerHTML = '';\n  modalFooterElement.appendChild(createButton('下载图片', 'primary', () => {\n    const currentImageSrc = previewImage.src;\n    const selectedStyle = styleSelector.value;\n    downloadImageFromDataUrl(currentImageSrc, memo, selectedStyle);\n  }));\n  modalFooterElement.appendChild(createButton('返回列表', 'secondary', () => renderMemoList()));\n\n  // 重新居中模态框\n  requestAnimationFrame(() => {\n    centerModal();\n  });\n\n  // CSS字体URL输入框和加载按钮事件\n  const fontUrlInput = modalBodyElement.querySelector('#fontUrlInput');\n  const loadFontUrlBtn = modalBodyElement.querySelector('#loadFontUrlBtn');\n  \n  // 为字体URL输入框添加焦点样式\n  addSelectFocusStyles('#fontUrlInput');\n  \n  // 字体URL加载按钮事件\n  if (loadFontUrlBtn && fontUrlInput) {\n    loadFontUrlBtn.addEventListener('click', () => {\n      const fontUrl = fontUrlInput.value.trim();\n      if (fontUrl) {\n        loadFontFromUrl(fontUrl, fontSelector);\n      } else {\n        toastr.warning('请输入字体URL或@import链接');\n      }\n    });\n    \n    // 支持回车键加载\n    fontUrlInput.addEventListener('keypress', (e) => {\n      if (e.key === 'Enter') {\n        const fontUrl = fontUrlInput.value.trim();\n        if (fontUrl) {\n          loadFontFromUrl(fontUrl, fontSelector);\n        }\n      }\n    });\n    \n    // 为输入框添加焦点样式\n    fontUrlInput.addEventListener('focus', function () {\n      this.style.borderColor = 'var(--SmartThemeQuoteColor, #4a9eff)';\n      this.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.08))';\n      this.style.boxShadow = '0 0 0 3px var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2))';\n    });\n    fontUrlInput.addEventListener('blur', function () {\n      this.style.borderColor = 'var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1))';\n      this.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05))';\n      this.style.boxShadow = 'none';\n    });\n  }\n}\n\n// 从DataURL下载图片的辅助函数\nfunction downloadImageFromDataUrl(dataUrl, memo, style) {\n  try {\n    // 生成更有意义的文件名\n    const displayTitle = getDisplayTitle(memo);\n    const safeTitle = displayTitle.replace(/[^\\w\\u4e00-\\u9fa5]/g, '_').substring(0, 20);\n    const timestamp = new Date().toISOString().slice(0, 16).replace(/[:\\-]/g, '');\n    const fileName = `memo_usage_report_${timestamp}.png`;\n\n    // 创建下载链接\n    const link = MemoDoc.createElement('a');\n    link.href = dataUrl;\n    link.download = fileName;\n\n    // 触发下载\n    MemoDoc.body.appendChild(link);\n    link.click();\n    MemoDoc.body.removeChild(link);\n\n    toastr.success('图片已下载！');\n    \n    // 保存样式偏好\n    saveStylePreference(style);\n  } catch (error) {\n    console.error('Memo: 下载图片失败:', error);\n    toastr.error('下载失败，请重试');\n  }\n}\n\n// 导入/导出功能\nfunction exportAllMemos() {\n  try {\n    // 收集所有memo数据\n    const allData = {};\n\n    // 遍历localStorage中所有以memo_开头的键\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && key.startsWith(LOCAL_STORAGE_KEY_PREFIX)) {\n        try {\n          const value = localStorage.getItem(key);\n          if (value) {\n            allData[key] = JSON.parse(value);\n          }\n        } catch (e) {\n          console.error(`解析键 ${key} 的数据时出错:`, e);\n        }\n      }\n    }\n\n    // 添加元数据\n    const exportData = {\n      version: '1.0',\n      timestamp: new Date().toISOString(),\n      data: allData\n    };\n\n    // 转换为JSON字符串\n    const jsonString = JSON.stringify(exportData, null, 2);\n\n    // 创建Blob并下载\n    const blob = new Blob([jsonString], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    const timestamp = new Date().toISOString().slice(0, 16).replace(/[:\\-]/g, '');\n\n    const a = MemoDoc.createElement('a');\n    a.href = url;\n    a.download = `memo_export_${timestamp}.json`;\n    MemoDoc.body.appendChild(a);\n    a.click();\n\n    // 清理\n    setTimeout(() => {\n      MemoDoc.body.removeChild(a);\n      URL.revokeObjectURL(url);\n    }, 0);\n\n    toastr.success('Memo数据导出成功！');\n    return true;\n  } catch (error) {\n    console.error('导出Memo数据失败:', error);\n    toastr.error('导出失败: ' + error.message);\n    return false;\n  }\n}\n\nfunction importMemos(fileContent, silent = false) {\n  try {\n    // 解析JSON数据\n    const importData = JSON.parse(fileContent);\n\n    // 基本验证\n    if (!importData.version || !importData.data) {\n      if (!silent) toastr.error('导入文件格式不正确！');\n      return false;\n    }\n\n    // 确认导入（在静默模式下跳过确认）\n    if (!silent && !confirm(`确定要导入数据吗？\\n这将导入 ${Object.keys(importData.data).length} 个聊天的Memo数据。\\n现有的同名数据将被覆盖！`)) {\n      return false;\n    }\n\n    // 导入数据\n    let importCount = 0;\n    for (const key in importData.data) {\n      if (key.startsWith(LOCAL_STORAGE_KEY_PREFIX)) {\n        try {\n          localStorage.setItem(key, JSON.stringify(importData.data[key]));\n          importCount++;\n        } catch (e) {\n          console.error(`导入键 ${key} 时出错:`, e);\n        }\n      }\n    }\n\n    if (!silent) toastr.success(`成功导入 ${importCount} 个聊天的Memo数据！`);\n\n    // 如果当前在列表视图，刷新显示\n    if (state.currentView === 'list') {\n      renderMemoList();\n    }\n\n    return true;\n  } catch (error) {\n    console.error('导入Memo数据失败:', error);\n    if (!silent) toastr.error('导入失败: ' + error.message);\n    return false;\n  }\n}\n\n// GitHub配置相关函数\nfunction loadGitHubConfig() {\n  try {\n    const configStr = localStorage.getItem(GITHUB_CONFIG_KEY);\n    if (configStr) {\n      const config = JSON.parse(configStr);\n      state.githubConfig = { ...state.githubConfig, ...config };\n    }\n  } catch (error) {\n    console.error('加载GitHub配置失败:', error);\n  }\n}\n\nfunction saveGitHubConfig(config) {\n  try {\n    // 更新状态\n    state.githubConfig = { ...state.githubConfig, ...config };\n    // 保存到localStorage\n    localStorage.setItem(GITHUB_CONFIG_KEY, JSON.stringify(state.githubConfig));\n    return true;\n  } catch (error) {\n    console.error('保存GitHub配置失败:', error);\n    return false;\n  }\n}\n\n// 样式偏好相关函数\nfunction loadStylePreference() {\n  try {\n    const styleStr = localStorage.getItem(STYLE_PREFERENCE_KEY);\n    if (styleStr) {\n      return styleStr;\n    }\n    return 'summer'; // 默认样式\n  } catch (error) {\n    console.error('加载样式偏好失败:', error);\n    return 'summer';\n  }\n}\n\nfunction saveStylePreference(style) {\n  try {\n    localStorage.setItem(STYLE_PREFERENCE_KEY, style);\n    return true;\n  } catch (error) {\n    console.error('保存样式偏好失败:', error);\n    return false;\n  }\n}\n\n// 渲染GitHub设置界面\nfunction renderGitHubSettings() {\n  // 设置当前视图状态\n  state.currentView = 'github-settings';\n\n  // 确保加载最新配置\n  loadGitHubConfig();\n\n  modalTitleElement.textContent = 'GitHub同步设置';\n\n  const html = `\n    <div class=\"memo-form\">\n      <div style=\"margin-bottom: 20px; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7)); font-size: 14px; line-height: 1.5;\">\n        配置GitHub同步，将Memo数据备份到您的GitHub仓库（建议私有）。\n        <br>需要一个具有至少Repo权限的GitHub个人访问令牌。\n      </div>\n      \n      <div class=\"memo-form-group\">\n        <label class=\"memo-form-label\" for=\"githubRepo\">备份路径：</label>\n        <input type=\"text\" id=\"githubRepo\" \n               placeholder=\"格式：Github用户名/项目名，例如：username/memo-data\" \n               value=\"${escapeHtml(state.githubConfig.repo)}\"\n               style=\"padding: 12px 16px;\n                      border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                      border-radius: 10px;\n                      background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n                      color: var(--SmartThemeBodyColor, #ffffff);\n                      font-size: 14px;\n                      transition: all 0.3s ease;\n                      font-weight: 500;\n                      width: 100%;\n                      box-sizing: border-box;\" />\n      </div>\n      \n      <div class=\"memo-form-group\">\n        <label class=\"memo-form-label\" for=\"githubToken\">个人访问令牌：<a href=\"https://github.com/settings/tokens\" target=\"_blank\" style=\"font-size: 12px; color: var(--SmartThemeQuoteColor, #4a9eff); text-decoration: underline; margin-left: 5px;\">创建令牌</a></label>\n        <input type=\"password\" id=\"githubToken\" \n               placeholder=\"粘贴您的GitHub个人访问令牌\" \n               value=\"${escapeHtml(state.githubConfig.token)}\"\n               style=\"padding: 12px 16px;\n                      border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                      border-radius: 10px;\n                      background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n                      color: var(--SmartThemeBodyColor, #ffffff);\n                      font-size: 14px;\n                      transition: all 0.3s ease;\n                      font-weight: 500;\n                      width: 100%;\n                      box-sizing: border-box;\" />\n      </div>\n      \n      <div class=\"memo-form-group\">\n        <label class=\"memo-form-label\" for=\"githubBranch\">分支名称（可选）：</label>\n        <input type=\"text\" id=\"githubBranch\" \n               placeholder=\"默认：main\" \n               value=\"${escapeHtml(state.githubConfig.branch)}\"\n               style=\"padding: 12px 16px;\n                      border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                      border-radius: 10px;\n                      background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n                      color: var(--SmartThemeBodyColor, #ffffff);\n                      font-size: 14px;\n                      transition: all 0.3s ease;\n                      font-weight: 500;\n                      width: 100%;\n                      box-sizing: border-box;\" />\n      </div>\n      \n      <div class=\"memo-form-group\">\n        <label class=\"memo-form-label\" for=\"githubPath\">保存路径（可选）：</label>\n        <input type=\"text\" id=\"githubPath\" \n               placeholder=\"默认：memo-data\" \n               value=\"${escapeHtml(state.githubConfig.path)}\"\n               style=\"padding: 12px 16px;\n                      border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                      border-radius: 10px;\n                      background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n                      color: var(--SmartThemeBodyColor, #ffffff);\n                      font-size: 14px;\n                      transition: all 0.3s ease;\n                      font-weight: 500;\n                      width: 100%;\n                      box-sizing: border-box;\" />\n      </div>\n      \n      <div class=\"memo-form-group\">\n        <label class=\"memo-form-label\" for=\"githubFilename\">自定义文件名（可选）：</label>\n        <input type=\"text\" id=\"githubFilename\" \n               placeholder=\"默认：自动生成时间戳文件名\" \n               value=\"${state.githubConfig.filename ? escapeHtml(state.githubConfig.filename) : ''}\"\n               style=\"padding: 12px 16px;\n                      border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                      border-radius: 10px;\n                      background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n                      color: var(--SmartThemeBodyColor, #ffffff);\n                      font-size: 14px;\n                      transition: all 0.3s ease;\n                      font-weight: 500;\n                      width: 100%;\n                      box-sizing: border-box;\" />\n        <div style=\"margin-top: 5px; font-size: 12px; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.5));\">\n          文件名将自动添加.json后缀，不需要包含路径\n        </div>\n      </div>\n      \n      <div style=\"display: flex; gap: 15px; margin-top: 20px;\">\n        <button id=\"githubSyncButton\" class=\"memo-button primary\" style=\"flex: 1; max-width: none; margin-top: 10px;\">\n          上传数据到GitHub\n        </button>\n        <button id=\"githubDownloadButton\" class=\"memo-button secondary\" style=\"flex: 1; max-width: none; margin-top: 10px;\">\n          从GitHub下载数据\n        </button>\n      </div>\n      \n      <div id=\"githubSyncStatus\" style=\"\n        margin-top: 15px;\n        padding: 10px;\n        border-radius: 8px;\n        background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n        color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7));\n        font-size: 12px;\n        text-align: center;\n        display: none;\n      \">同步状态显示区域</div>\n    </div>\n  `;\n\n  modalBodyElement.innerHTML = html;\n\n  // 绑定输入框样式\n  ['githubRepo', 'githubToken', 'githubBranch', 'githubPath', 'githubFilename'].forEach(id => {\n    const input = MemoDoc.getElementById(id);\n    if (input) {\n      input.addEventListener('focus', function () {\n        this.style.borderColor = 'var(--SmartThemeQuoteColor, #4a9eff)';\n        this.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.08))';\n        this.style.boxShadow = '0 0 0 3px var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2))';\n      });\n      input.addEventListener('blur', function () {\n        this.style.borderColor = 'var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1))';\n        this.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05))';\n        this.style.boxShadow = 'none';\n      });\n    }\n  });\n\n  // 绑定按钮事件\n  const syncButton = MemoDoc.getElementById('githubSyncButton');\n  if (syncButton) {\n    syncButton.addEventListener('click', () => {\n      saveGitHubSettingsAndSync('upload');\n    });\n  }\n\n  const downloadButton = MemoDoc.getElementById('githubDownloadButton');\n  if (downloadButton) {\n    downloadButton.addEventListener('click', () => {\n      saveGitHubSettingsAndSync('download');\n    });\n  }\n\n  // 渲染底部按钮\n  modalFooterElement.innerHTML = '';\n  modalFooterElement.appendChild(createButton('保存设置', 'primary', saveGitHubSettingsAndReturn));\n  modalFooterElement.appendChild(createButton('返回', 'secondary', () => renderMemoList()));\n\n  // 重新居中模态框\n  requestAnimationFrame(() => {\n    centerModal();\n  });\n}\n\n// 保存GitHub设置并返回列表\nfunction saveGitHubSettingsAndReturn() {\n  const repo = MemoDoc.getElementById('githubRepo')?.value?.trim() || '';\n  const token = MemoDoc.getElementById('githubToken')?.value?.trim() || '';\n  const branch = MemoDoc.getElementById('githubBranch')?.value?.trim() || 'main';\n  const path = MemoDoc.getElementById('githubPath')?.value?.trim() || 'memo-data';\n  const filename = MemoDoc.getElementById('githubFilename')?.value?.trim() || '';\n\n  // 更新配置\n  const config = {\n    repo,\n    token,\n    branch,\n    path,\n    filename\n  };\n\n  if (saveGitHubConfig(config)) {\n    toastr.success('GitHub设置已保存');\n    renderMemoList();\n  } else {\n    toastr.error('保存设置失败');\n  }\n}\n\n// 保存GitHub设置并执行同步\nfunction saveGitHubSettingsAndSync(action) {\n  const repo = MemoDoc.getElementById('githubRepo')?.value?.trim() || '';\n  const token = MemoDoc.getElementById('githubToken')?.value?.trim() || '';\n  const branch = MemoDoc.getElementById('githubBranch')?.value?.trim() || 'main';\n  const path = MemoDoc.getElementById('githubPath')?.value?.trim() || 'memo-data';\n  const filename = MemoDoc.getElementById('githubFilename')?.value?.trim() || '';\n\n  // 验证输入\n  if (!repo || !token) {\n    toastr.error('请填写备份路径和访问令牌');\n    return;\n  }\n\n  // 验证仓库格式\n  if (!repo.includes('/')) {\n    toastr.error('备份路径格式不正确，应为：Github用户名/项目名');\n    return;\n  }\n\n  // 更新配置\n  const config = {\n    repo,\n    token,\n    branch,\n    path,\n    filename\n  };\n\n  if (saveGitHubConfig(config)) {\n    // 显示同步状态区域\n    const statusElem = MemoDoc.getElementById('githubSyncStatus');\n    if (statusElem) {\n      statusElem.style.display = 'block';\n      statusElem.textContent = '正在准备同步...';\n    }\n\n    // 执行同步操作\n    if (action === 'upload') {\n      uploadToGitHub(statusElem);\n    } else if (action === 'download') {\n      downloadFromGitHub(statusElem);\n    }\n  } else {\n    toastr.error('保存设置失败');\n  }\n}\n\n// 上传数据到GitHub\nasync function uploadToGitHub(statusElem) {\n  try {\n    if (!state.githubConfig.repo || !state.githubConfig.token) {\n      updateSyncStatus(statusElem, '❌ 缺少GitHub仓库信息或令牌', 'error');\n      return;\n    }\n\n    updateSyncStatus(statusElem, '🔄 正在收集本地数据...', 'info');\n\n    // 收集所有memo数据\n    const allData = {};\n    // 遍历localStorage中所有以memo_开头的键\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && key.startsWith(LOCAL_STORAGE_KEY_PREFIX) && key !== GITHUB_CONFIG_KEY) {\n        try {\n          const value = localStorage.getItem(key);\n          if (value) {\n            allData[key] = JSON.parse(value);\n          }\n        } catch (e) {\n          console.error(`解析键 ${key} 的数据时出错:`, e);\n        }\n      }\n    }\n\n    // 添加元数据\n    const exportData = {\n      version: '1.0',\n      timestamp: new Date().toISOString(),\n      data: allData\n    };\n\n    // 转换为JSON字符串\n    const jsonString = JSON.stringify(exportData, null, 2);\n\n    // 生成时间戳（无论是否使用自定义文件名，都需要这个时间戳用于提交信息）\n    const timestamp = new Date().toISOString().slice(0, 16).replace(/[:\\-]/g, '');\n\n    // 生成文件名\n    let fileName;\n    if (state.githubConfig.filename) {\n      // 使用用户自定义的文件名\n      fileName = state.githubConfig.filename.endsWith('.json') ?\n        state.githubConfig.filename :\n        `${state.githubConfig.filename}.json`;\n    } else {\n      // 使用默认的时间戳文件名\n      fileName = `memo_data_${timestamp}.json`;\n    }\n    const filePath = `${state.githubConfig.path}/${fileName}`;\n\n    updateSyncStatus(statusElem, '🔄 正在连接GitHub...', 'info');\n\n    // GitHub API请求\n    const [owner, repo] = state.githubConfig.repo.split('/');\n    const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`;\n\n    // 准备请求头\n    const headers = {\n      'Authorization': `token ${state.githubConfig.token}`,\n      'Content-Type': 'application/json',\n      'Accept': 'application/vnd.github.v3+json'\n    };\n\n    // 将内容编码为Base64\n    const base64Content = btoa(unescape(encodeURIComponent(jsonString)));\n\n    // 检查文件是否已存在\n    let sha = null;\n    try {\n      const checkResponse = await fetch(apiUrl, {\n        method: 'GET',\n        headers: headers\n      });\n\n      if (checkResponse.ok) {\n        // 文件已存在，获取其SHA值用于更新\n        const fileData = await checkResponse.json();\n        sha = fileData.sha;\n        updateSyncStatus(statusElem, '🔄 文件已存在，准备更新...', 'info');\n      }\n    } catch (error) {\n      // 忽略错误，表示文件可能不存在\n      console.log('文件不存在或检查出错，将创建新文件');\n    }\n\n    // 准备请求体\n    const requestBody = {\n      message: `Update memo data: ${timestamp}`,\n      content: base64Content,\n      branch: state.githubConfig.branch\n    };\n\n    // 如果文件已存在，添加SHA以实现覆盖\n    if (sha) {\n      requestBody.sha = sha;\n    }\n\n    // 提交数据\n    const response = await fetch(apiUrl, {\n      method: 'PUT',\n      headers: headers,\n      body: JSON.stringify(requestBody)\n    });\n\n    const result = await response.json();\n\n    if (response.ok) {\n      // 更新最后同步时间\n      saveGitHubConfig({\n        lastSync: new Date().toISOString()\n      });\n      updateSyncStatus(statusElem, `✅ 上传成功! 文件已${sha ? '更新' : '保存'}为: ${fileName}`, 'success');\n    } else {\n      updateSyncStatus(statusElem, `❌ 上传失败: ${result.message || '未知错误'}`, 'error');\n    }\n  } catch (error) {\n    console.error('上传到GitHub失败:', error);\n    updateSyncStatus(statusElem, `❌ 上传出错: ${error.message || '未知错误'}`, 'error');\n  }\n}\n\n// 从GitHub下载数据\nasync function downloadFromGitHub(statusElem) {\n  try {\n    if (!state.githubConfig.repo || !state.githubConfig.token) {\n      updateSyncStatus(statusElem, '❌ 缺少GitHub仓库信息或令牌', 'error');\n      return;\n    }\n\n    updateSyncStatus(statusElem, '🔄 正在连接GitHub...', 'info');\n\n    // GitHub API请求 - 获取目录内容\n    const [owner, repo] = state.githubConfig.repo.split('/');\n    const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${state.githubConfig.path}`;\n\n    // 准备请求头\n    const headers = {\n      'Authorization': `token ${state.githubConfig.token}`,\n      'Accept': 'application/vnd.github.v3+json'\n    };\n\n    // 获取目录列表\n    const response = await fetch(apiUrl, {\n      method: 'GET',\n      headers: headers\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      updateSyncStatus(statusElem, `❌ 获取文件列表失败: ${errorData.message || '未知错误'}`, 'error');\n      return;\n    }\n\n    const files = await response.json();\n\n    // 过滤所有JSON文件\n    const jsonFiles = files.filter(file =>\n      file.type === 'file' && file.name.endsWith('.json')\n    );\n\n    if (jsonFiles.length === 0) {\n      updateSyncStatus(statusElem, '❌ 未找到备份数据文件', 'error');\n      return;\n    }\n\n    // 如果指定了文件名，尝试查找对应文件\n    let targetFile = null;\n    if (state.githubConfig.filename) {\n      const filename = state.githubConfig.filename.endsWith('.json') ?\n        state.githubConfig.filename :\n        `${state.githubConfig.filename}.json`;\n\n      targetFile = jsonFiles.find(file => file.name === filename);\n\n      // 如果指定了文件名但找不到文件，显示错误信息\n      if (!targetFile) {\n        updateSyncStatus(statusElem, `❌ 未找到指定的文件: ${filename}`, 'error');\n        return;\n      }\n\n      // 找到了指定文件，直接下载\n      updateSyncStatus(statusElem, `🔄 正在下载指定备份: ${targetFile.name}...`, 'info');\n      await downloadAndImportFile(targetFile.path, targetFile.name, statusElem);\n      return;\n    }\n\n    // 如果没有指定文件名，显示文件选择界面\n    // 按文件名排序，最新的在前面\n    jsonFiles.sort((a, b) => b.name.localeCompare(a.name));\n\n    // 清空状态消息，显示文件选择界面\n    if (statusElem) {\n      statusElem.innerHTML = `\n        <div style=\"text-align: left; margin-bottom: 10px;\">请选择要下载的备份文件：</div>\n        <div style=\"max-height: 200px; overflow-y: auto; border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1)); border-radius: 8px; padding: 8px; margin-bottom: 15px;\">\n          ${jsonFiles.map((file, index) => `\n            <div class=\"github-file-item\" style=\"\n              padding: 8px;\n              margin-bottom: 5px;\n              border-radius: 6px;\n              display: flex;\n              justify-content: space-between;\n              align-items: center;\n              background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n              border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n              transition: all 0.2s ease;\n            \">\n              <div class=\"file-info\" style=\"\n                flex: 1;\n                cursor: pointer;\n                display: flex;\n                justify-content: space-between;\n                align-items: center;\n                padding-right: 10px;\n              \"\n              data-path=\"${file.path}\"\n              data-name=\"${file.name}\"\n              onmouseover=\"this.parentNode.style.background='var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.08))'; this.parentNode.style.borderColor='var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.3))';\" \n              onmouseout=\"this.parentNode.style.background='var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05))'; this.parentNode.style.borderColor='var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1))';\"\n              >\n                <span style=\"font-weight: 500;\">${file.name}</span>\n                <span style=\"font-size: 11px; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.6));\">\n                  ${formatFileSize(file.size)}\n                </span>\n              </div>\n              <button class=\"delete-file-btn\" style=\"\n                background: rgba(255, 71, 87, 0.2);\n                color: #ff4757;\n                border: none;\n                border-radius: 4px;\n                padding: 4px 8px;\n                cursor: pointer;\n                font-size: 12px;\n                transition: all 0.2s ease;\n                display: flex;\n                align-items: center;\n                justify-content: center;\n              \"\n              data-path=\"${file.path}\"\n              data-sha=\"${file.sha}\"\n              data-name=\"${file.name}\"\n              onmouseover=\"this.style.background='rgba(255, 71, 87, 0.3)';\" \n              onmouseout=\"this.style.background='rgba(255, 71, 87, 0.2)';\"\n              >\n                <i class=\"fas fa-trash-alt\"></i>\n              </button>\n            </div>\n          `).join('')}\n        </div>\n      `;\n\n      // 为文件项添加点击事件\n      const fileItems = statusElem.querySelectorAll('.file-info');\n      fileItems.forEach(item => {\n        item.addEventListener('click', async () => {\n          const path = item.getAttribute('data-path');\n          const name = item.getAttribute('data-name');\n          await downloadAndImportFile(path, name, statusElem);\n        });\n      });\n\n      // 为删除按钮添加点击事件\n      const deleteButtons = statusElem.querySelectorAll('.delete-file-btn');\n      deleteButtons.forEach(button => {\n        button.addEventListener('click', async (e) => {\n          e.stopPropagation(); // 防止触发父元素的点击事件\n          const path = button.getAttribute('data-path');\n          const sha = button.getAttribute('data-sha');\n          const name = button.getAttribute('data-name');\n\n          if (confirm(`确定要删除文件 \"${name}\" 吗？此操作不可恢复！`)) {\n            await deleteGitHubFile(path, sha, statusElem);\n          }\n        });\n      });\n    }\n  } catch (error) {\n    console.error('从GitHub下载数据失败:', error);\n    updateSyncStatus(statusElem, `❌ 下载出错: ${error.message || '未知错误'}`, 'error');\n  }\n}\n\n// 格式化文件大小\nfunction formatFileSize(bytes) {\n  if (bytes < 1024) return bytes + ' B';\n  else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';\n  else return (bytes / 1048576).toFixed(1) + ' MB';\n}\n\n// 下载并导入文件\nasync function downloadAndImportFile(pathOrUrl, fileName, statusElem) {\n  try {\n    updateSyncStatus(statusElem, `🔄 正在下载文件: ${fileName}...`, 'info');\n\n    // 提取文件路径信息\n    const [owner, repo] = state.githubConfig.repo.split('/');\n\n    // 确定是路径还是URL\n    let filePath;\n    if (pathOrUrl.startsWith('http')) {\n      // 这是一个URL，尝试从中提取路径\n      const urlParts = pathOrUrl.split('/');\n      filePath = pathOrUrl;\n    } else {\n      // 这是一个路径\n      filePath = pathOrUrl;\n    }\n\n    // 使用GitHub API获取文件内容\n    const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${filePath}`;\n\n    const headers = {\n      'Authorization': `token ${state.githubConfig.token}`,\n      'Accept': 'application/vnd.github.v3+json'\n    };\n\n    const fileResponse = await fetch(apiUrl, {\n      method: 'GET',\n      headers: headers\n    });\n\n    if (!fileResponse.ok) {\n      const errorData = await fileResponse.json();\n      updateSyncStatus(statusElem, `❌ 下载文件失败: ${errorData.message || '未知错误'}`, 'error');\n      return false;\n    }\n\n    const fileData = await fileResponse.json();\n\n    // GitHub API返回的内容是Base64编码的\n    // 解码Base64内容，处理换行符问题\n    let base64Content = fileData.content.replace(/\\n/g, '');\n\n    // 解码Base64内容\n    const decodedContent = decodeURIComponent(\n      Array.prototype.map.call(\n        atob(base64Content),\n        c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)\n      ).join('')\n    );\n\n    // 导入数据\n    updateSyncStatus(statusElem, '🔄 正在导入数据...', 'info');\n    const importResult = importMemos(decodedContent, true); // 使用静默模式\n\n    if (importResult) {\n      // 更新最后同步时间\n      saveGitHubConfig({\n        lastSync: new Date().toISOString()\n      });\n      updateSyncStatus(statusElem, `✅ 数据导入成功! 来自: ${fileName}`, 'success');\n\n      // 刷新Memo列表\n      setTimeout(() => {\n        if (state.currentView === 'github-settings') {\n          renderMemoList();\n        }\n      }, 2000);\n\n      return true;\n    } else {\n      updateSyncStatus(statusElem, '❌ 数据导入失败', 'error');\n      return false;\n    }\n  } catch (error) {\n    console.error('文件下载和导入失败:', error);\n    updateSyncStatus(statusElem, `❌ 导入出错: ${error.message || '未知错误'}`, 'error');\n    return false;\n  }\n}\n\n// 更新同步状态显示\nfunction updateSyncStatus(statusElem, message, type = 'info') {\n  if (!statusElem) return;\n\n  statusElem.textContent = message;\n  statusElem.style.display = 'block';\n\n  // 根据类型设置样式\n  switch (type) {\n    case 'error':\n      statusElem.style.background = 'rgba(255, 71, 87, 0.2)';\n      statusElem.style.color = '#ff4757';\n      statusElem.style.border = '1px solid rgba(255, 71, 87, 0.3)';\n      break;\n    case 'success':\n      statusElem.style.background = 'rgba(46, 213, 115, 0.2)';\n      statusElem.style.color = '#2ed573';\n      statusElem.style.border = '1px solid rgba(46, 213, 115, 0.3)';\n      break;\n    case 'info':\n    default:\n      statusElem.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05))';\n      statusElem.style.color = 'var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7))';\n      statusElem.style.border = '1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1))';\n  }\n}\n\n// 文件选择器 - 导入功能\nfunction createFileSelector() {\n  // 移除已存在的选择器\n  const existingSelector = MemoDoc.getElementById('memoFileSelector');\n  if (existingSelector) {\n    existingSelector.remove();\n  }\n\n  // 创建新的文件选择器\n  const fileSelector = MemoDoc.createElement('input');\n  fileSelector.type = 'file';\n  fileSelector.id = 'memoFileSelector';\n  fileSelector.accept = '.json';\n  fileSelector.style.display = 'none';\n\n  fileSelector.addEventListener('change', (event) => {\n    const file = event.target.files[0];\n    if (!file) return;\n\n    const reader = new FileReader();\n    reader.onload = (e) => {\n      const content = e.target.result;\n      importMemos(content);\n    };\n    reader.readAsText(file);\n  });\n\n  MemoDoc.body.appendChild(fileSelector);\n  return fileSelector;\n}\n\n// 添加复制Memo内容的函数\nfunction copyMemoContent(memoId) {\n  // 确定要使用的聊天上下文 - 优先使用手动选择的上下文\n  const context = state.selectedChatContext || getCurrentChatContext();\n  const memos = loadMemosFromStorage(context);\n  const memo = memos.find(m => m.id === memoId);\n\n  if (!memo) {\n    if (typeof toastr !== 'undefined') {\n      toastr.error('找不到要复制的Memo！');\n    }\n    return;\n  }\n\n  // 获取要复制的内容（只复制笔记内容）\n  const contentToCopy = memo.content || '';\n\n  // 使用Clipboard API复制内容\n  try {\n    navigator.clipboard.writeText(contentToCopy).then(() => {\n      if (typeof toastr !== 'undefined') {\n        toastr.success('笔记内容已复制到剪贴板！');\n      }\n    }, (err) => {\n      console.error('复制失败:', err);\n      fallbackCopyTextToClipboard(contentToCopy);\n    });\n  } catch (err) {\n    console.error('Clipboard API不可用，使用备用方法:', err);\n    fallbackCopyTextToClipboard(contentToCopy);\n  }\n}\n\n// 添加备用复制方法（用于不支持Clipboard API的浏览器）\nfunction fallbackCopyTextToClipboard(text) {\n  const textArea = MemoDoc.createElement('textarea');\n  textArea.value = text;\n\n  // 设置样式使其不可见\n  textArea.style.position = 'fixed';\n  textArea.style.top = '0';\n  textArea.style.left = '0';\n  textArea.style.width = '2em';\n  textArea.style.height = '2em';\n  textArea.style.padding = '0';\n  textArea.style.border = 'none';\n  textArea.style.outline = 'none';\n  textArea.style.boxShadow = 'none';\n  textArea.style.background = 'transparent';\n\n  MemoDoc.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n\n  try {\n    const successful = MemoDoc.execCommand('copy');\n    if (successful) {\n      if (typeof toastr !== 'undefined') {\n        toastr.success('笔记内容已复制到剪贴板！');\n      }\n    } else {\n      if (typeof toastr !== 'undefined') {\n        toastr.error('复制失败，请手动复制！');\n      }\n    }\n  } catch (err) {\n    console.error('fallbackCopy失败:', err);\n    if (typeof toastr !== 'undefined') {\n      toastr.error('复制失败，请手动复制！');\n    }\n  }\n\n  MemoDoc.body.removeChild(textArea);\n}\n\n// 添加确保Font Awesome加载的函数\nfunction ensureFontAwesomeLoaded() {\n  // 检查是否已加载Font Awesome\n  const fontAwesomeLoaded = Array.from(MemoDoc.querySelectorAll('link')).some(link =>\n    link.href && (link.href.includes('font-awesome') || link.href.includes('fontawesome'))\n  );\n\n  // 如果没有加载，则添加Font Awesome CDN\n  if (!fontAwesomeLoaded) {\n    const fontAwesomeLink = MemoDoc.createElement('link');\n    fontAwesomeLink.rel = 'stylesheet';\n    fontAwesomeLink.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css';\n    fontAwesomeLink.integrity = 'sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==';\n    fontAwesomeLink.crossOrigin = 'anonymous';\n    fontAwesomeLink.referrerPolicy = 'no-referrer';\n    MemoDoc.head.appendChild(fontAwesomeLink);\n  }\n}\n\n// 删除GitHub文件\nasync function deleteGitHubFile(path, sha, statusElem) {\n  try {\n    if (!state.githubConfig.repo || !state.githubConfig.token) {\n      updateSyncStatus(statusElem, '❌ 缺少GitHub仓库信息或令牌', 'error');\n      return false;\n    }\n\n    updateSyncStatus(statusElem, '🔄 正在删除文件...', 'info');\n\n    // GitHub API请求\n    const [owner, repo] = state.githubConfig.repo.split('/');\n    const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/${path}`;\n\n    // 准备请求头\n    const headers = {\n      'Authorization': `token ${state.githubConfig.token}`,\n      'Content-Type': 'application/json',\n      'Accept': 'application/vnd.github.v3+json'\n    };\n\n    // 删除文件需要提供SHA值\n    if (!sha) {\n      updateSyncStatus(statusElem, '❌ 删除失败: 缺少文件SHA值', 'error');\n      return false;\n    }\n\n    // 生成时间戳用于提交信息\n    const timestamp = new Date().toISOString().slice(0, 16).replace(/[:\\-]/g, '');\n\n    // 发送删除请求\n    const response = await fetch(apiUrl, {\n      method: 'DELETE',\n      headers: headers,\n      body: JSON.stringify({\n        message: `Delete memo file: ${timestamp}`,\n        sha: sha,\n        branch: state.githubConfig.branch\n      })\n    });\n\n    if (response.ok) {\n      updateSyncStatus(statusElem, '✅ 文件已成功删除', 'success');\n\n      // 2秒后刷新文件列表\n      setTimeout(() => {\n        downloadFromGitHub(statusElem);\n      }, 2000);\n\n      return true;\n    } else {\n      const result = await response.json();\n      updateSyncStatus(statusElem, `❌ 删除失败: ${result.message || '未知错误'}`, 'error');\n      return false;\n    }\n  } catch (error) {\n    console.error('删除GitHub文件失败:', error);\n    updateSyncStatus(statusElem, `❌ 删除出错: ${error.message || '未知错误'}`, 'error');\n    return false;\n  }\n}\n\n// 清除所有本地Memo数据\nfunction clearAllLocalMemos() {\n  try {\n    // 确认是否要清除所有Memo\n    if (!confirm('确定要清除所有本地保存的Memo吗？此操作不可恢复！')) {\n      return false;\n    }\n\n    // 获取所有以memo_开头的localStorage键\n    const keysToRemove = [];\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && key.startsWith(LOCAL_STORAGE_KEY_PREFIX) && key !== GITHUB_CONFIG_KEY) {\n        keysToRemove.push(key);\n      }\n    }\n\n    // 删除所有找到的键\n    keysToRemove.forEach(key => {\n      localStorage.removeItem(key);\n    });\n\n    // 显示成功消息\n    if (typeof toastr !== 'undefined') {\n      toastr.success(`已清除 ${keysToRemove.length} 个聊天的Memo数据！`);\n    }\n\n    // 刷新Memo列表\n    renderMemoList();\n    return true;\n  } catch (error) {\n    console.error('清除Memo数据失败:', error);\n    if (typeof toastr !== 'undefined') {\n      toastr.error('清除失败: ' + error.message);\n    }\n    return false;\n  }\n}\n\nfunction selectAllBetween() {\n  if (selectionState.selectedParagraphs.length < 2) {\n    return; // 需要至少选择2个段落\n  }\n\n  // 获取所有段落元素\n  const allParagraphs = Array.from(MemoDoc.querySelectorAll('.mes_text p, .message_text p, .mes_text div:not(.memo-annotation-btn):not([class*=\"btn\"]):not([class*=\"button\"]), .message_text div:not(.memo-annotation-btn):not([class*=\"btn\"]):not([class*=\"button\"])'))\n    .filter(p => {\n      const textContent = getPureTextContent(p);\n      return textContent && textContent.length >= 1;\n    });\n\n  // 按DOM顺序排序已选中的段落\n  const sortedSelected = sortParagraphsByDOMOrder([...selectionState.selectedParagraphs]);\n  \n  // 找到第一个和最后一个选中段落在所有段落中的索引\n  const firstSelectedIndex = allParagraphs.findIndex(p => p === sortedSelected[0].element);\n  const lastSelectedIndex = allParagraphs.findIndex(p => p === sortedSelected[sortedSelected.length - 1].element);\n\n  if (firstSelectedIndex === -1 || lastSelectedIndex === -1) {\n    console.warn('Memo: 无法找到选中段落的位置');\n    return;\n  }\n\n  // 选中第一个和最后一个之间的所有段落\n  for (let i = firstSelectedIndex; i <= lastSelectedIndex; i++) {\n    const paragraph = allParagraphs[i];\n    \n    // 检查是否已经选中\n    const isAlreadySelected = selectionState.selectedParagraphs.some(p => p.element === paragraph);\n    \n    if (!isAlreadySelected) {\n      const paragraphText = getPureTextContent(paragraph);\n      if (paragraphText) {\n        const messageId = getMessageId(paragraph);\n        \n        selectionState.selectedParagraphs.push({\n          element: paragraph,\n          text: paragraphText,\n          messageId: messageId,\n          timestamp: Date.now()\n        });\n        \n        paragraph.classList.add('memo-paragraph-selected');\n      }\n    }\n  }\n\n  // 更新所有按钮状态\n  updateAllAnnotationButtons();\n  updateCompleteButton();\n  \n  // 显示成功提示\n  if (typeof toastr !== 'undefined') {\n    const newSelections = (lastSelectedIndex - firstSelectedIndex + 1) - sortedSelected.length;\n    toastr.success(`已选中中间的 ${newSelections} 个段落！`);\n  }\n}\n\n// 更新全选按钮状态\nfunction updateSelectAllButton() {\n  const selectAllBtn = selectionState.controlPanel?.querySelector('#memoSelectAllBetween');\n  \n  if (!selectAllBtn || !selectionState.isMultiSelectMode) {\n    return;\n  }\n\n  // 检查是否需要显示全选按钮\n  const shouldShowButton = checkShouldShowSelectAllButton();\n  \n  if (shouldShowButton) {\n    selectAllBtn.style.display = 'block';\n    \n    // 检查是否已经全选了中间段落\n    const isAllSelected = checkAllBetweenSelected();\n    if (isAllSelected) {\n      selectAllBtn.textContent = '已全选';\n      selectAllBtn.disabled = true;\n      selectAllBtn.classList.add('secondary');\n    } else {\n      selectAllBtn.textContent = '全选中间';\n      selectAllBtn.disabled = false;\n      selectAllBtn.classList.remove('secondary');\n    }\n  } else {\n    selectAllBtn.style.display = 'none';\n  }\n}\n\n// 检查是否应该显示全选按钮\nfunction checkShouldShowSelectAllButton() {\n  if (selectionState.selectedParagraphs.length < 2) {\n    return false; // 需要至少选择2个段落\n  }\n\n  // 获取所有段落元素\n  const allParagraphs = Array.from(MemoDoc.querySelectorAll('.mes_text p, .message_text p, .mes_text div:not(.memo-annotation-btn):not([class*=\"btn\"]):not([class*=\"button\"]), .message_text div:not(.memo-annotation-btn):not([class*=\"btn\"]):not([class*=\"button\"])'))\n    .filter(p => {\n      const textContent = getPureTextContent(p);\n      return textContent && textContent.length >= 1;\n    });\n\n  // 按DOM顺序排序已选中的段落\n  const sortedSelected = sortParagraphsByDOMOrder([...selectionState.selectedParagraphs]);\n  \n  // 找到第一个和最后一个选中段落在所有段落中的索引\n  const firstSelectedIndex = allParagraphs.findIndex(p => p === sortedSelected[0].element);\n  const lastSelectedIndex = allParagraphs.findIndex(p => p === sortedSelected[sortedSelected.length - 1].element);\n\n  if (firstSelectedIndex === -1 || lastSelectedIndex === -1) {\n    return false;\n  }\n\n  // 检查中间是否有未选中的段落\n  const totalBetween = lastSelectedIndex - firstSelectedIndex + 1;\n  return totalBetween > selectionState.selectedParagraphs.length;\n}\n\n// 检查是否已经全选了中间段落\nfunction checkAllBetweenSelected() {\n  if (selectionState.selectedParagraphs.length < 2) {\n    return false;\n  }\n\n  // 获取所有段落元素\n  const allParagraphs = Array.from(MemoDoc.querySelectorAll('.mes_text p, .message_text p, .mes_text div:not(.memo-annotation-btn):not([class*=\"btn\"]):not([class*=\"button\"]), .message_text div:not(.memo-annotation-btn):not([class*=\"btn\"]):not([class*=\"button\"])'))\n    .filter(p => {\n      const textContent = getPureTextContent(p);\n      return textContent && textContent.length >= 1;\n    });\n\n  // 按DOM顺序排序已选中的段落\n  const sortedSelected = sortParagraphsByDOMOrder([...selectionState.selectedParagraphs]);\n  \n  // 找到第一个和最后一个选中段落在所有段落中的索引\n  const firstSelectedIndex = allParagraphs.findIndex(p => p === sortedSelected[0].element);\n  const lastSelectedIndex = allParagraphs.findIndex(p => p === sortedSelected[sortedSelected.length - 1].element);\n\n  if (firstSelectedIndex === -1 || lastSelectedIndex === -1) {\n    return false;\n  }\n\n  // 检查第一个和最后一个之间的所有段落是否都已选中\n  for (let i = firstSelectedIndex; i <= lastSelectedIndex; i++) {\n    const paragraph = allParagraphs[i];\n    const isSelected = selectionState.selectedParagraphs.some(p => p.element === paragraph);\n    if (!isSelected) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n// 字体管理相关函数 - 专门处理网络字体\nfunction loadCustomFonts() {\n  try {\n    const fontsStr = localStorage.getItem(FONT_STORAGE_KEY);\n    if (fontsStr) {\n      const fonts = JSON.parse(fontsStr);\n      // 只保留网络字体（有url属性的）\n      const networkFonts = fonts.filter(font => font.url && !font.data);\n      state.fontConfig.customFonts = networkFonts;\n      return networkFonts;\n    }\n    return [];\n  } catch (error) {\n    console.error('加载网络字体失败:', error);\n    return [];\n  }\n}\n\nfunction saveCustomFonts(fonts) {\n  try {\n    // 只保存网络字体\n    const networkFonts = fonts.filter(font => font.url && !font.data);\n    localStorage.setItem(FONT_STORAGE_KEY, JSON.stringify(networkFonts));\n    state.fontConfig.customFonts = networkFonts;\n    return true;\n  } catch (error) {\n    console.error('保存网络字体失败:', error);\n    return false;\n  }\n}\n\nfunction loadFontPreference() {\n  try {\n    const fontStr = localStorage.getItem(FONT_PREFERENCE_KEY);\n    if (fontStr) {\n      state.fontConfig.currentFont = fontStr;\n      return fontStr;\n    }\n    return 'QiushuiShotai'; // 默认字体\n  } catch (error) {\n    console.error('加载字体偏好失败:', error);\n    return 'QiushuiShotai';\n  }\n}\n\nfunction saveFontPreference(fontName) {\n  try {\n    localStorage.setItem(FONT_PREFERENCE_KEY, fontName);\n    state.fontConfig.currentFont = fontName;\n    return true;\n  } catch (error) {\n    console.error('保存字体偏好失败:', error);\n    return false;\n  }\n}\n\n// 加载所有保存的网络字体\nasync function loadAllCustomFonts() {\n  const fonts = loadCustomFonts();\n  const loadPromises = fonts.map(font => {\n    if (font.url && !state.fontConfig.loadedFonts.has(font.name)) {\n      return loadFontFromCssUrl(font.url, font.name).catch(error => {\n        console.error(`跳过加载网络字体 \"${font.name}\":`, error);\n      });\n    }\n  });\n  \n  await Promise.all(loadPromises);\n}\n\n// 添加网络字体到存储\nfunction addNetworkFont(fontName, fontUrl) {\n  try {\n    const fonts = loadCustomFonts();\n    \n    // 检查是否已存在\n    const existingIndex = fonts.findIndex(f => f.name === fontName || f.url === fontUrl);\n    \n    const fontData = {\n      id: Date.now(),\n      name: fontName,\n      url: fontUrl,\n      type: 'network',\n      addedTime: new Date().toISOString()\n    };\n    \n    if (existingIndex >= 0) {\n      fonts[existingIndex] = fontData;\n    } else {\n      fonts.push(fontData);\n    }\n    \n    saveCustomFonts(fonts);\n    return true;\n  } catch (error) {\n    console.error('添加网络字体失败:', error);\n    return false;\n  }\n}\n\n// 删除网络字体\nfunction deleteNetworkFont(fontName) {\n  try {\n    const fonts = loadCustomFonts();\n    const filteredFonts = fonts.filter(f => f.name !== fontName);\n    saveCustomFonts(filteredFonts);\n    \n    // 如果删除的是当前使用的字体，重置为默认字体\n    if (state.fontConfig.currentFont === fontName) {\n      saveFontPreference('QiushuiShotai');\n    }\n    \n    // 从已加载字体中移除\n    state.fontConfig.loadedFonts.delete(fontName);\n    \n    return true;\n  } catch (error) {\n    console.error('删除网络字体失败:', error);\n    return false;\n  }\n}\n\n// CSS字体URL加载相关函数\nasync function loadFontFromUrl(fontUrl, fontSelector) {\n  try {\n    toastr.info('正在加载网络字体...');\n    \n    // 解析字体URL\n    const cssUrl = parseFontUrl(fontUrl);\n    if (!cssUrl) {\n      toastr.error('无法解析字体URL，请检查格式是否正确');\n      return;\n    }\n    \n    // 获取CSS内容并提取字体名称\n    const fontName = await loadAndExtractFontName(cssUrl);\n    if (!fontName) {\n      toastr.error('无法从CSS中提取字体名称');\n      return;\n    }\n    \n    // 检查字体是否已经加载\n    if (state.fontConfig.loadedFonts.has(fontName)) {\n      toastr.info(`字体 \"${fontName}\" 已经加载过了`);\n      updateFontSelector(fontName, fontSelector);\n      return;\n    }\n    \n    // 加载字体\n    await loadFontFromCssUrl(cssUrl, fontName);\n    \n    // 保存到localStorage\n    addNetworkFont(fontName, cssUrl);\n    \n    // 更新字体选择器\n    updateFontSelector(fontName, fontSelector);\n    \n    toastr.success(`网络字体 \"${fontName}\" 加载成功！`);\n    \n  } catch (error) {\n    console.error('加载网络字体失败:', error);\n    toastr.error(`加载字体失败：${error.message}`);\n  }\n}\n\n// 解析字体URL，支持@import和直接CSS链接\nfunction parseFontUrl(input) {\n  const trimmedInput = input.trim();\n  \n  try {\n    // 处理@import格式：@import url(\"https://fontsapi.zeoseven.com/670/main/result.css\");\n    if (trimmedInput.startsWith('@import')) {\n      const urlMatch = trimmedInput.match(/@import\\s+url\\s*\\(\\s*[\"']?([^\"')]+)[\"']?\\s*\\)/);\n      if (urlMatch) {\n        return urlMatch[1];\n      }\n    }\n    \n    // 处理直接CSS链接\n    if (trimmedInput.startsWith('http')) {\n      return trimmedInput;\n    }\n    \n    return null;\n  } catch (error) {\n    console.error('解析字体URL失败:', error);\n    return null;\n  }\n}\n\n// 加载CSS并提取字体名称\nasync function loadAndExtractFontName(cssUrl) {\n  try {\n    // 获取CSS内容\n    const response = await fetch(cssUrl);\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n    \n    const cssContent = await response.text();\n    \n    // 从CSS内容中提取字体名称\n    const fontName = extractFontNameFromCss(cssContent);\n    \n    return fontName;\n  } catch (error) {\n    console.error('获取CSS内容失败:', error);\n    throw error;\n  }\n}\n\n// 改进的字体名称提取，从CSS内容中提取真正的字体名称\nfunction extractFontNameFromCss(cssContent) {\n  try {\n    // 尝试匹配各种可能的font-family声明格式\n    const patterns = [\n      // 标准格式：font-family: \"fontname\";\n      /font-family:\\s*[\"']([^\"']+)[\"']/g,\n      // CSS变量格式：--font-family: \"fontname\";\n      /--font-family:\\s*[\"']([^\"']+)[\"']/g,\n      // 无引号格式：font-family: fontname;\n      /font-family:\\s*([^;,\\s]+)/g,\n      // @font-face格式：font-family: \"fontname\"\n      /@font-face\\s*\\{[^}]*font-family:\\s*[\"']([^\"']+)[\"']/g\n    ];\n    \n    const foundFonts = new Set();\n    \n    // 尝试所有模式\n    for (const pattern of patterns) {\n      let match;\n      const regex = new RegExp(pattern.source, pattern.flags);\n      while ((match = regex.exec(cssContent)) !== null) {\n        const fontName = match[1].trim();\n        // 排除通用字体名称\n        if (fontName && !isGenericFontName(fontName)) {\n          foundFonts.add(fontName);\n        }\n      }\n    }\n    \n    if (foundFonts.size > 0) {\n      // 返回第一个找到的非通用字体名称\n      return Array.from(foundFonts)[0];\n    }\n    \n    // 如果都没找到，生成一个唯一名称\n    const timestamp = Date.now().toString().slice(-6);\n    return `WebFont_${timestamp}`;\n    \n  } catch (error) {\n    console.error('从CSS提取字体名称失败:', error);\n    const timestamp = Date.now().toString().slice(-6);\n    return `WebFont_${timestamp}`;\n  }\n}\n\n// 检查是否是通用字体名称\nfunction isGenericFontName(fontName) {\n  const genericFonts = [\n    'serif', 'sans-serif', 'monospace', 'cursive', 'fantasy',\n    'system-ui', 'ui-serif', 'ui-sans-serif', 'ui-monospace',\n    'Arial', 'Helvetica', 'Times', 'Courier', 'Georgia', 'Verdana'\n  ];\n  \n  return genericFonts.some(generic => \n    fontName.toLowerCase().includes(generic.toLowerCase())\n  );\n}\n\n// 使用CSS link标签加载字体\nasync function loadFontFromCssUrl(cssUrl, fontName) {\n  return new Promise((resolve, reject) => {\n    // 检查是否已经有相同的link标签\n    const existingLink = MemoDoc.querySelector(`link[href=\"${cssUrl}\"]`);\n    if (existingLink) {\n      // 已经加载过了，直接标记为已加载\n      state.fontConfig.loadedFonts.add(fontName);\n      resolve();\n      return;\n    }\n    \n    // 创建link标签加载CSS\n    const link = MemoDoc.createElement('link');\n    link.rel = 'stylesheet';\n    link.href = cssUrl;\n    link.crossOrigin = 'anonymous'; // 支持跨域\n    \n    link.onload = () => {\n      // CSS加载成功\n      console.log(`CSS字体文件加载成功: ${cssUrl}`);\n      state.fontConfig.loadedFonts.add(fontName);\n      resolve();\n    };\n    \n    link.onerror = () => {\n      console.error(`加载CSS字体文件失败: ${cssUrl}`);\n      reject(new Error(`无法加载CSS文件：${cssUrl}`));\n    };\n    \n    // 添加到页面\n    MemoDoc.head.appendChild(link);\n    \n    // 设置超时，防止无限等待\n    setTimeout(() => {\n      reject(new Error('字体加载超时'));\n    }, 10000);\n  });\n}\n\n// 更新字体选择器（用于网络字体）\nfunction updateFontSelector(fontName, fontSelector) {\n  // 检查选项是否已存在\n  const existingOption = Array.from(fontSelector.options).find(option => option.value === fontName);\n  \n  if (!existingOption) {\n    // 添加新的选项到字体选择器\n    const option = MemoDoc.createElement('option');\n    option.value = fontName;\n    option.textContent = `${fontName} - 网络字体`;\n    fontSelector.appendChild(option);\n  }\n  \n  // 选中新字体\n  fontSelector.value = fontName;\n  \n  // 保存字体偏好\n  saveFontPreference(fontName);\n  \n  // 如果在年度总结界面，还需要更新报告字体选择器\n  const reportFontSelector = MemoDoc.getElementById('reportFontSelector');\n  if (reportFontSelector && reportFontSelector !== fontSelector) {\n    // 检查报告字体选择器中是否已存在该选项\n    const reportExistingOption = Array.from(reportFontSelector.options).find(option => option.value === fontName);\n    \n    if (!reportExistingOption) {\n      const reportOption = MemoDoc.createElement('option');\n      reportOption.value = fontName;\n      reportOption.textContent = `${fontName} - 网络字体`;\n      reportFontSelector.appendChild(reportOption);\n    }\n    \n    // 如果当前是在年度总结界面触发的字体加载，也选中报告字体选择器中的新字体\n    if (state.currentView === 'yearly-report-result') {\n      reportFontSelector.value = fontName;\n    }\n  }\n  \n  console.log(`字体已更新为: ${fontName}`);\n}\n\n// 为选择器添加焦点样式\nfunction addSelectFocusStyles(selector) {\n  const element = MemoDoc.querySelector(selector);\n  if (element) {\n    element.addEventListener('focus', function () {\n      this.style.borderColor = 'var(--SmartThemeQuoteColor, #4a9eff)';\n      this.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.08))';\n      this.style.boxShadow = '0 0 0 3px var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2))';\n    });\n    element.addEventListener('blur', function () {\n      this.style.borderColor = 'var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1))';\n      this.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05))';\n      this.style.boxShadow = 'none';\n    });\n  }\n}\n\n// 重新生成图片\nfunction regenerateImageWithNewSettings(memo, style, font, previewImage, loadingIndicator, styleSelector, fontSelector) {\n  // 显示加载指示器\n  loadingIndicator.style.display = 'block';\n  styleSelector.disabled = true;\n  fontSelector.disabled = true;\n\n  // 生成新图片\n  generateMemoImage(memo, style, font).then(newImageDataUrl => {\n    previewImage.src = newImageDataUrl;\n\n    // 保存偏好\n    saveStylePreference(style);\n    saveFontPreference(font);\n\n    // 隐藏加载指示器\n    loadingIndicator.style.display = 'none';\n    styleSelector.disabled = false;\n    fontSelector.disabled = false;\n\n    toastr.success('图片生成成功！');\n  }).catch(error => {\n    console.error('Memo: 生成图片失败:', error);\n\n    // 隐藏加载指示器\n    loadingIndicator.style.display = 'none';\n    styleSelector.disabled = false;\n    fontSelector.disabled = false;\n\n    toastr.error('生成图片失败，请重试');\n  });\n}\n\n// 加载自定义颜色配置\nfunction loadCustomColorConfig() {\n  try {\n    const configStr = localStorage.getItem(CUSTOM_COLOR_CONFIG_KEY);\n    if (configStr) {\n      const config = JSON.parse(configStr);\n      // 合并到state中，保持默认值\n      state.customColorConfig = {\n        ...state.customColorConfig,\n        ...config\n      };\n      return config;\n    }\n    return state.customColorConfig; // 返回默认配置\n  } catch (error) {\n    console.error('加载自定义颜色配置失败:', error);\n    return state.customColorConfig;\n  }\n}\n\n// 保存自定义颜色配置\nfunction saveCustomColorConfig(config) {\n  try {\n    // 更新state\n    state.customColorConfig = {\n      ...state.customColorConfig,\n      ...config\n    };\n    localStorage.setItem(CUSTOM_COLOR_CONFIG_KEY, JSON.stringify(state.customColorConfig));\n    return true;\n  } catch (error) {\n    console.error('保存自定义颜色配置失败:', error);\n    return false;\n  }\n}\n\n// =========================== LLM 相关功能 ===========================\n\n// 加载LLM配置\nfunction loadLLMConfig() {\n    try {\n      const configStr = localStorage.getItem(LLM_CONFIG_KEY);\n      if (configStr) {\n        const config = JSON.parse(configStr);\n        state.llmConfig = { ...state.llmConfig, ...config };\n      }\n    } catch (error) {\n      console.error('加载LLM配置失败:', error);\n    }\n  }\n  \n  // 保存LLM配置\n  function saveLLMConfig(config) {\n    try {\n      // 更新状态\n      state.llmConfig = { ...state.llmConfig, ...config };\n      // 保存到localStorage\n      localStorage.setItem(LLM_CONFIG_KEY, JSON.stringify(state.llmConfig));\n      return true;\n    } catch (error) {\n      console.error('保存LLM配置失败:', error);\n      return false;\n    }\n  }\n  \n  // 测试LLM连接\n  async function testLLMConnection(apiUrl, apiKey) {\n    try {\n      // 验证输入参数\n      if (!apiUrl || !apiKey) {\n        throw new Error('API URL和API Key都是必填项');\n      }\n\n      // 检查URL格式\n      try {\n        new URL(apiUrl);\n      } catch (e) {\n        throw new Error('API URL格式不正确，请检查URL是否完整（包含 http:// 或 https://）');\n      }\n\n      // 首先尝试获取模型列表来测试连接\n      try {\n        const modelsUrl = apiUrl.replace(/\\/chat\\/completions$/, '/models');\n        const modelsResponse = await fetch(modelsUrl, {\n          method: 'GET',\n          headers: {\n            'Authorization': `Bearer ${apiKey}`,\n            'Content-Type': 'application/json'\n          }\n        });\n\n        if (modelsResponse.ok) {\n          const modelsData = await modelsResponse.json();\n          return { success: true, data: modelsData, method: 'models' };\n        }\n      } catch (e) {\n        // 如果模型列表API失败，继续尝试聊天完成API\n        console.log('模型列表API测试失败，尝试聊天完成API');\n      }\n\n      // 尝试聊天完成API，使用更通用的测试消息\n      const testPayloads = [\n        // 标准OpenAI格式\n        {\n          model: 'gpt-3.5-turbo',\n          messages: [{ role: 'user', content: 'hi' }],\n          max_tokens: 5\n        },\n        // 如果有已配置的模型，使用已配置的模型\n        ...(state.llmConfig.model ? [{\n          model: state.llmConfig.model,\n          messages: [{ role: 'user', content: 'hi' }],\n          max_tokens: 5\n        }] : []),\n        // 尝试不指定模型（某些API可能有默认模型）\n        {\n          messages: [{ role: 'user', content: 'hi' }],\n          max_tokens: 5\n        }\n      ];\n\n      let lastError = null;\n      \n      for (const payload of testPayloads) {\n        try {\n          const response = await fetch(apiUrl, {\n            method: 'POST',\n            headers: {\n              'Content-Type': 'application/json',\n              'Authorization': `Bearer ${apiKey}`\n            },\n            body: JSON.stringify(payload)\n          });\n\n          if (response.ok) {\n            const data = await response.json();\n            return { success: true, data, method: 'chat', payload };\n          } else {\n            // 记录错误但继续尝试下一个payload\n            let errorMessage = `HTTP ${response.status}: ${response.statusText}`;\n            \n            try {\n              const errorData = await response.json();\n              if (errorData.error && errorData.error.message) {\n                errorMessage += ` - ${errorData.error.message}`;\n              } else if (errorData.message) {\n                errorMessage += ` - ${errorData.message}`;\n              }\n            } catch (e) {\n              // 无法解析错误响应\n            }\n            \n            lastError = new Error(errorMessage);\n            \n            // 如果是401/403错误，直接返回（认证问题）\n            if (response.status === 401 || response.status === 403) {\n              throw lastError;\n            }\n          }\n        } catch (e) {\n          lastError = e;\n          // 如果是网络错误，直接返回\n          if (e.name === 'TypeError' && e.message.includes('fetch')) {\n            throw e;\n          }\n        }\n      }\n\n      // 如果所有payload都失败了，抛出最后一个错误\n      throw lastError || new Error('所有测试方法都失败了');\n\n    } catch (error) {\n      console.error('LLM连接测试失败:', error);\n      \n      // 网络错误的特殊处理\n      if (error.name === 'TypeError' && error.message.includes('fetch')) {\n        return { \n          success: false, \n          error: '网络连接失败，请检查网络连接或API服务是否可用' \n        };\n      }\n      \n      // 针对常见错误码提供解决建议\n      let errorMessage = error.message;\n      if (errorMessage.includes('401')) {\n        errorMessage += '\\n建议：请检查API Key是否正确';\n      } else if (errorMessage.includes('403')) {\n        errorMessage += '\\n建议：API Key可能没有访问权限';\n      } else if (errorMessage.includes('404')) {\n        errorMessage += '\\n建议：请检查API URL是否正确';\n      } else if (errorMessage.includes('429')) {\n        errorMessage += '\\n建议：API调用频率过高，请稍后再试';\n      } else if (errorMessage.includes('500')) {\n        errorMessage += '\\n建议：服务器内部错误，请稍后再试';\n      } else if (errorMessage.includes('503')) {\n        errorMessage += '\\n建议：服务暂时不可用，请检查API服务状态或稍后再试';\n      }\n      \n      return { success: false, error: errorMessage };\n    }\n  }\n  \n  // 获取可用模型列表\n  async function fetchAvailableModels(apiUrl, apiKey) {\n    try {\n      // 尝试多种可能的模型列表API端点\n      const possibleEndpoints = [\n        apiUrl.replace(/\\/chat\\/completions$/, '/models'),\n        apiUrl.replace(/\\/chat\\/completions$/, '/v1/models'),\n        apiUrl.replace(/\\/v1\\/chat\\/completions$/, '/v1/models'),\n        apiUrl.replace(/\\/v1\\/chat\\/completions$/, '/models')\n      ];\n\n      // 去重\n      const uniqueEndpoints = [...new Set(possibleEndpoints)];\n\n      for (const endpoint of uniqueEndpoints) {\n        try {\n          const response = await fetch(endpoint, {\n            method: 'GET',\n            headers: {\n              'Authorization': `Bearer ${apiKey}`,\n              'Content-Type': 'application/json'\n            }\n          });\n\n          if (response.ok) {\n            const data = await response.json();\n            \n            // 尝试解析不同格式的响应\n            let models = [];\n            \n            if (data.data && Array.isArray(data.data)) {\n              // OpenAI格式\n              models = data.data.map(model => model.id || model.name).filter(Boolean);\n            } else if (data.models && Array.isArray(data.models)) {\n              // 某些API的models字段格式\n              models = data.models.map(model => model.id || model.name || model).filter(Boolean);\n            } else if (Array.isArray(data)) {\n              // 直接是数组格式\n              models = data.map(model => model.id || model.name || model).filter(Boolean);\n            } else if (data.object === 'list' && data.data) {\n              // OpenAI标准格式\n              models = data.data.map(model => model.id || model.name).filter(Boolean);\n            }\n\n            if (models.length > 0) {\n              return models;\n            }\n          }\n        } catch (e) {\n          console.log(`尝试端点 ${endpoint} 失败:`, e.message);\n          continue;\n        }\n      }\n\n      // 如果所有端点都失败，返回常见模型列表\n      console.log('所有模型列表API都失败，返回常见模型列表');\n      return [\n        'gpt-3.5-turbo',\n        'gpt-4',\n        'gpt-4-turbo',\n        'gpt-4o',\n        'claude-3-sonnet',\n        'claude-3-haiku',\n        'claude-3-opus',\n        'gemini-pro',\n        'llama-2-70b',\n        'mixtral-8x7b'\n      ];\n    } catch (error) {\n      console.error('获取模型列表失败:', error);\n      // 返回一些常见模型作为备选\n      return [\n        'gpt-3.5-turbo',\n        'gpt-4',\n        'gpt-4-turbo',\n        'gpt-4o',\n        'claude-3-sonnet',\n        'claude-3-haiku',\n        'claude-3-opus',\n        'gemini-pro',\n        'llama-2-70b',\n        'mixtral-8x7b'\n      ];\n    }\n  }\n  \n  // 调用LLM生成年度总结\n  async function generateYearlyReport(selectedMemos, statusCallback) {\n    try {\n      if (!state.llmConfig.apiUrl || !state.llmConfig.apiKey) {\n        throw new Error('请先配置LLM API设置');\n      }\n  \n      if (!state.llmConfig.model) {\n        throw new Error('请先选择LLM模型');\n      }\n  \n      if (!selectedMemos || selectedMemos.length === 0) {\n        throw new Error('没有选择任何memo数据');\n      }\n  \n      statusCallback('正在准备数据...');\n  \n      // 构建提示词\n      const prompt = ` <memo>${JSON.stringify(selectedMemos, null, 2)}</memo>\n      <memo>中是用户在使用Sillytavern时记录的一些Memo，其中的每个字段的含义分别是\n  - title：用户给笔记设置的标题\n  - content：用户记下的笔记内容\n  - originalText：用户摘抄下的原始段落\n  - createAt/updateAt：笔记创建/最后编辑的时间\n  另外每一个memo的命名分别为\"memo_用户对话的角色名-用户给这篇对话起的名字\".\n  请基于Memo中记录的内容，根据以下参考资料，生成一篇对用户Memo记录的行为报告\n  参考资料：\n  你是否知道网易云/美团外卖每年都会根据用户在他们的app上的使用行为，为用户生成一篇年度总结？请模仿这种年度总结，生成一篇分析用户的Memo记录的行为报告。\n  需要富有冷幽默，用一针见血的言辞对用户的Memo记录进行犀利的讽刺或吐槽。\n  吐槽的内容包括但不限于用户记录的时间/用户记录的内容/用户摘录的内容/用户对角色的记录次数等等。吐槽过程中可以适当使用emoji，增添幽默感。\n  完成吐槽后，你还需要发挥创意，生成用户的MBTI推测/喜好分析等用户画像分析（即给用户贴标签）、对用户未来使用Memo的趣味推测、对记录的Memo中提及的角色的命运/未来的展望等等扩展内容，不必拘束于以上提到的形式，请尽情发挥创意，增加报告的趣味性和创新性！\n  注意，不必使用css或html生成网页美化格式，但可使用Markdown格式生成简单的表格对用户喜好/习惯/关键词出现次数等进行分析，让数据更直观。必须使用中文输出。`;\n  \n      statusCallback('Memo使用报告生成中...');\n  \n      const response = await fetch(state.llmConfig.apiUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${state.llmConfig.apiKey}`\n        },\n        body: JSON.stringify({\n          model: state.llmConfig.model,\n          messages: [\n            { role: 'user', content: prompt }\n          ],\n          temperature: state.llmConfig.temperature,\n          max_tokens: 2000\n        })\n      });\n  \n      if (!response.ok) {\n        throw new Error(`LLM API调用失败: HTTP ${response.status}`);\n      }\n  \n      const data = await response.json();\n      \n      if (data.choices && data.choices[0] && data.choices[0].message) {\n        return data.choices[0].message.content;\n      } else {\n        throw new Error('LLM返回数据格式异常');\n      }\n    } catch (error) {\n      console.error('行为报告生成失败:', error);\n      throw error;\n    }\n  }\n  \n  // 生成年度总结长图\n  function generateYearlyReportImage(reportText, style = 'summer', customFont = 'QiushuiShotai') {\n    return new Promise((resolve, reject) => {\n      try {\n        // 加载自定义颜色配置\n        loadCustomColorConfig();\n        \n        // 使用现有的主题配置，并添加自定义主题\n        const themes = {\n          marshmallow: {\n            name: '棉花糖 - 粉蓝',\n            background: {\n              colors: ['#f8f9ff', '#f0f4ff', '#fff0f5', '#fff5f0']\n            },\n            colors: {\n              userInfo: '#666',\n              time: '#999',\n              title: '#2c3e50',\n              accent: '#4a9eff',\n              excerpt: '#34495e',\n              notes: '#555',\n              brand: '#999',\n              decorativeLine: '#4a9eff',\n              separatorLine: '#e0e0e0'\n            }\n          },\n          drowninlove: {\n            name: '泥沼中 - 青黑',\n            background: {\n              colors: ['#000000', '#0a0a0a', '#050505', '#000000']\n            },\n            colors: {\n              userInfo: '#00cccc',\n              time: '#008888',\n              title: '#00ffff',\n              accent: '#00ffff',\n              excerpt: '#00eeee',\n              notes: '#00dddd',\n              brand: '#00aaaa',\n              decorativeLine: '#00ffff',\n              separatorLine: '#003333'\n            }\n          },\n          summer: {\n            name: '长夏 - 绿色',\n            background: {\n              colors: ['#f0fff0', '#e8f8e8', '#d8f0d8', '#c8e8c8']\n            },\n            colors: {\n              userInfo: '#2d5a2d',\n              time: '#5a7a5a',\n              title: '#1e3a1e',\n              accent: '#28a745',\n              excerpt: '#2d5a2d',\n              notes: '#3d6a3d',\n              brand: '#5a7a5a',\n              decorativeLine: '#28a745',\n              separatorLine: '#b8d8b8'\n            }\n          },\n          papper: {\n            name: '如是说 - 信纸',\n            background: {\n              colors: ['#f5f2e8', '#f8f5eb', '#f2efdf', '#f6f3e5']\n            },\n            colors: {\n              userInfo: '#5d4e37',\n              time: '#8b7d6b',\n              title: '#2c5aa0',\n              accent: '#2c5aa0',\n              excerpt: '#2c5aa0',\n              notes: '#4a4a4a',\n              brand: '#8b7d6b',\n              decorativeLine: '#2c5aa0',\n              separatorLine: '#d4c5a9'\n            }\n          },\n          rose: {\n            name: '朱砂痣 - 朱红',\n            background: {\n              colors: ['#fdf5f5', '#f8e6e6', '#f0d0d0', '#e8c0c0']\n            },\n            colors: {\n              userInfo: '#8b4a4a',\n              time: '#a05656',\n              title: '#a64545',\n              accent: '#a64545',\n              excerpt: '#a64545',\n              notes: '#735555',\n              brand: '#a05656',\n              decorativeLine: '#a64545',\n              separatorLine: '#e8c5c5'\n            }\n          },\n          ink: {\n            name: '缓缓 - 淡墨',\n            background: {\n              colors: ['#f8f8f8', '#f0f0f0', '#e8e8e8', '#f5f5f5']\n            },\n            colors: {\n              userInfo: '#2c3e50',\n              time: '#34495e',\n              title: '#1a237e',\n              accent: '#3949ab',\n              excerpt: '#283593',\n              notes: '#1a237e',\n              brand: '#5c6bc0',\n              decorativeLine: '#3949ab',\n              separatorLine: '#bdc3c7'\n            }\n          },\n          custom: {\n            name: '自定义配色',\n            background: {\n              colors: [\n                state.customColorConfig.color1,\n                state.customColorConfig.color2,\n                state.customColorConfig.color1,\n                state.customColorConfig.color2\n              ]\n            },\n            colors: {\n              userInfo: state.customColorConfig.textColors.userInfo,\n              time: state.customColorConfig.textColors.time,\n              title: state.customColorConfig.textColors.title,\n              accent: state.customColorConfig.textColors.accent,\n              excerpt: state.customColorConfig.textColors.excerpt,\n              notes: state.customColorConfig.textColors.notes,\n              brand: state.customColorConfig.textColors.brand,\n              decorativeLine: state.customColorConfig.textColors.decorativeLine,\n              separatorLine: state.customColorConfig.textColors.separatorLine\n            }\n          }\n        };\n\n        const theme = themes[style] || themes.summer;\n        const canvas = MemoDoc.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n\n        // 设置画布尺寸\n        const width = 800;\n        const padding = 40;\n        const contentWidth = width - padding * 2;\n\n        // 先创建一个临时canvas来计算实际需要的高度\n        const tempCanvas = MemoDoc.createElement('canvas');\n        const tempCtx = tempCanvas.getContext('2d');\n        tempCanvas.width = width;\n        tempCanvas.height = 2000; // 给一个足够大的高度用于计算\n        \n        // 计算实际内容高度\n        const actualHeight = calculateActualContentHeight(tempCtx, reportText, width, theme, customFont);\n        \n        // 使用计算出的实际高度，并增加适当的底部边距\n        const height = actualHeight + 40; // 只增加40px的底部边距，而不是100px\n\n        canvas.width = width;\n        canvas.height = height;\n\n        // 设置画布缩放以获得更清晰的文字\n        const scale = 2;\n        canvas.width = width * scale;\n        canvas.height = height * scale;\n        canvas.style.width = width + 'px';\n        canvas.style.height = height + 'px';\n        ctx.scale(scale, scale);\n\n        // 绘制背景\n        drawBackground(ctx, width, height, theme);\n\n        // 绘制内容\n        drawYearlyReportContent(ctx, reportText, width, height, theme, customFont).then(() => {\n          resolve(canvas.toDataURL('image/png', 0.9));\n        }).catch(reject);\n\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  \n  // 解析markdown内容并转换为可渲染的结构\n  function parseMarkdownForCanvas(text) {\n    const lines = text.split('\\n');\n    const parsedContent = [];\n    let currentTable = null;\n    let inCodeBlock = false;\n    \n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i];\n      \n      // 检查代码块\n      if (line.trim().startsWith('```')) {\n        inCodeBlock = !inCodeBlock;\n        continue;\n      }\n      \n      if (inCodeBlock) {\n        parsedContent.push({\n          type: 'code',\n          content: line,\n          indent: 0\n        });\n        continue;\n      }\n      \n      // 检查标题\n      if (line.match(/^#{1,6}\\s/)) {\n        const level = line.match(/^#+/)[0].length;\n        parsedContent.push({\n          type: 'heading',\n          content: line.replace(/^#+\\s*/, ''),\n          level: level\n        });\n        continue;\n      }\n      \n      // 检查表格\n      if (line.includes('|') && line.trim() !== '') {\n        if (!currentTable) {\n          currentTable = {\n            type: 'table',\n            headers: [],\n            rows: [],\n            isHeaderSeparator: false\n          };\n        }\n        \n        // 检查是否是表格分隔行（如 |---|---|）\n        if (line.match(/^\\s*\\|[\\s\\-\\|]+\\|\\s*$/)) {\n          currentTable.isHeaderSeparator = true;\n        } else {\n          const cells = line.split('|').map(cell => cell.trim()).filter(cell => cell !== '');\n          \n          if (currentTable.headers.length === 0 && !currentTable.isHeaderSeparator) {\n            currentTable.headers = cells;\n          } else if (currentTable.isHeaderSeparator) {\n            currentTable.rows.push(cells);\n          }\n        }\n        \n        // 检查下一行是否还是表格\n        if (i + 1 >= lines.length || !lines[i + 1].includes('|')) {\n          if (currentTable.headers.length > 0) {\n            parsedContent.push(currentTable);\n          }\n          currentTable = null;\n        }\n        continue;\n      }\n      \n      // 检查列表项 - 修复编号列表解析\n      if (line.match(/^\\s*[-*+]\\s/) || line.match(/^\\s*\\d+\\.\\s/)) {\n        const indent = line.match(/^\\s*/)[0].length;\n        const numberedMatch = line.match(/^\\s*(\\d+)\\.\\s/);\n        const isNumbered = !!numberedMatch;\n        let listMarker = '';\n        let content = '';\n        \n        if (isNumbered) {\n          // 编号列表：保存数字编号\n          listMarker = numberedMatch[1] + '.';\n          content = line.replace(/^\\s*\\d+\\.\\s*/, '');\n        } else {\n          // 无序列表：保存原始标记符号\n          const markerMatch = line.match(/^\\s*([-*+])\\s/);\n          listMarker = markerMatch ? markerMatch[1] : '-';\n          content = line.replace(/^\\s*[-*+]\\s*/, '');\n        }\n        \n        parsedContent.push({\n          type: 'list',\n          content: content,\n          indent: indent,\n          numbered: isNumbered,\n          marker: listMarker\n        });\n        continue;\n      }\n      \n      // 检查引用\n      if (line.match(/^\\s*>\\s/)) {\n        parsedContent.push({\n          type: 'quote',\n          content: line.replace(/^\\s*>\\s*/, ''),\n          indent: 0\n        });\n        continue;\n      }\n      \n      // 普通段落\n      if (line.trim() !== '') {\n        parsedContent.push({\n          type: 'paragraph',\n          content: line.trim(),\n          indent: 0\n        });\n      } else {\n        parsedContent.push({\n          type: 'empty',\n          content: '',\n          indent: 0\n        });\n      }\n    }\n    \n    return parsedContent;\n  }\n  \n  // 计算实际内容高度的函数\n  function calculateActualContentHeight(ctx, reportText, width, theme, customFont) {\n    const padding = 40;\n    const contentWidth = width - padding * 2;\n    let currentY = padding + 20;\n\n    // 标题高度\n    ctx.font = `bold 32px \"${customFont}\", serif`;\n    currentY += 50; // 标题高度\n\n    // 装饰线\n    currentY += 40;\n\n    // 解析markdown内容\n    const parsedContent = parseMarkdownForCanvas(reportText);\n    \n    // 计算每个元素的高度\n    parsedContent.forEach(item => {\n      switch (item.type) {\n        case 'heading':\n          const headingSize = Math.max(24 - (item.level - 1) * 3, 16);\n          currentY += headingSize + 15;\n          \n          // 装饰线高度\n          if (item.level <= 2) {\n            currentY += 10;\n          }\n          break;\n          \n        case 'table':\n          // 简单估算表格高度\n          if (item.headers && item.headers.length > 0) {\n            currentY += 30; // 表头高度\n          }\n          if (item.rows && item.rows.length > 0) {\n            currentY += item.rows.length * 25; // 行高度\n          }\n          currentY += 20; // 表格间距\n          break;\n          \n        case 'list':\n          ctx.font = `14px \"${customFont}\", serif`;\n          const listLines = wrapText(ctx, item.content, contentWidth - item.indent - 30);\n          currentY += listLines.length * 20;\n          break;\n          \n        case 'quote':\n          ctx.font = `italic 14px \"${customFont}\", serif`;\n          const quoteLines = wrapText(ctx, item.content, contentWidth - 20);\n          currentY += quoteLines.length * 22;\n          break;\n          \n        case 'code':\n          currentY += 25;\n          break;\n          \n        case 'empty':\n          currentY += 15;\n          break;\n          \n        case 'paragraph':\n        default:\n          ctx.font = `16px \"${customFont}\", serif`;\n          const paragraphLines = wrapText(ctx, item.content, contentWidth);\n          currentY += paragraphLines.length * 24 + 8; // 内容高度 + 段落间距\n          break;\n      }\n    });\n\n    // 底部标语\n    currentY += 20 + 20; // 间距 + 标语高度\n\n    return currentY;\n  }\n  \n  // 绘制表格\n  function drawTable(ctx, table, x, y, maxWidth, theme, font) {\n    const cellPadding = 8;\n    const rowHeight = 25;\n    const headerHeight = 30;\n    \n    // 计算列宽\n    const columnCount = Math.max(table.headers.length, Math.max(...table.rows.map(row => row.length)));\n    const columnWidth = (maxWidth - cellPadding * 2) / columnCount;\n    \n    let currentY = y;\n    \n    // 保存当前文本对齐设置\n    const originalTextAlign = ctx.textAlign;\n    \n    // 绘制表头\n    if (table.headers.length > 0) {\n      // 表头背景\n      ctx.fillStyle = theme.colors.accent + '20'; // 半透明背景\n      ctx.fillRect(x, currentY, maxWidth, headerHeight);\n      \n      // 表头边框\n      ctx.strokeStyle = theme.colors.accent;\n      ctx.lineWidth = 2;\n      ctx.strokeRect(x, currentY, maxWidth, headerHeight);\n      \n      // 表头文字\n      ctx.fillStyle = theme.colors.accent;\n      ctx.font = `bold 14px \"${font}\", serif`;\n      ctx.textAlign = 'center';\n      \n      table.headers.forEach((header, index) => {\n        const cellX = x + index * columnWidth + columnWidth / 2;\n        const cellY = currentY + headerHeight / 2 + 5;\n        ctx.fillText(header, cellX, cellY);\n        \n        // 列分隔线\n        if (index < table.headers.length - 1) {\n          ctx.beginPath();\n          ctx.moveTo(x + (index + 1) * columnWidth, currentY);\n          ctx.lineTo(x + (index + 1) * columnWidth, currentY + headerHeight);\n          ctx.stroke();\n        }\n      });\n      \n      currentY += headerHeight;\n    }\n    \n    // 绘制数据行\n    ctx.font = `13px \"${font}\", serif`;\n    ctx.fillStyle = theme.colors.notes;\n    \n    table.rows.forEach((row, rowIndex) => {\n      // 行背景（交替颜色）\n      if (rowIndex % 2 === 1) {\n        ctx.fillStyle = theme.colors.accent + '10';\n        ctx.fillRect(x, currentY, maxWidth, rowHeight);\n      }\n      \n      // 行边框\n      ctx.strokeStyle = theme.colors.separatorLine;\n      ctx.lineWidth = 1;\n      ctx.strokeRect(x, currentY, maxWidth, rowHeight);\n      \n      // 单元格文字\n      ctx.fillStyle = theme.colors.notes;\n      \n      row.forEach((cell, cellIndex) => {\n        if (cellIndex < columnCount) {\n          const cellX = x + cellIndex * columnWidth + cellPadding;\n          const cellY = currentY + rowHeight / 2 + 5;\n          \n          // 文本截断处理\n          let displayText = cell;\n          const maxCellWidth = columnWidth - cellPadding * 2;\n          while (ctx.measureText(displayText).width > maxCellWidth && displayText.length > 0) {\n            displayText = displayText.slice(0, -1);\n          }\n          if (displayText !== cell && displayText.length > 0) {\n            displayText += '...';\n          }\n          \n          ctx.textAlign = 'left';\n          ctx.fillText(displayText, cellX, cellY);\n          \n          // 列分隔线\n          if (cellIndex < columnCount - 1) {\n            ctx.strokeStyle = theme.colors.separatorLine;\n            ctx.beginPath();\n            ctx.moveTo(x + (cellIndex + 1) * columnWidth, currentY);\n            ctx.lineTo(x + (cellIndex + 1) * columnWidth, currentY + rowHeight);\n            ctx.stroke();\n          }\n        }\n      });\n      \n      currentY += rowHeight;\n    });\n    \n    // 恢复原始的文本对齐设置\n    ctx.textAlign = originalTextAlign;\n    \n    return currentY - y; // 返回表格的总高度\n  }\n  \n  // 绘制年度总结内容（支持markdown）\n  function drawYearlyReportContent(ctx, reportText, width, height, theme, customFont) {\n    return new Promise((resolve) => {\n      const padding = 40;\n      const contentWidth = width - padding * 2;\n      let currentY = padding + 20;\n\n      // 标题\n      ctx.font = `bold 32px \"${customFont}\", serif`;\n      ctx.fillStyle = theme.colors.title;\n      ctx.textAlign = 'center';\n      ctx.fillText('Memo使用报告', width / 2, currentY);\n      currentY += 50;\n\n      // 装饰线\n      ctx.strokeStyle = theme.colors.decorativeLine;\n      ctx.lineWidth = 3;\n      ctx.beginPath();\n      ctx.moveTo(width / 2 - 60, currentY);\n      ctx.lineTo(width / 2 + 60, currentY);\n      ctx.stroke();\n      currentY += 40;\n\n    // 解析markdown内容\n    const parsedContent = parseMarkdownForCanvas(reportText);\n    \n      // 绘制解析后的内容\n      ctx.textAlign = 'left';\n      \n    parsedContent.forEach(item => {\n      switch (item.type) {\n        case 'heading':\n          const headingSize = Math.max(24 - (item.level - 1) * 3, 16);\n            ctx.font = `bold ${headingSize}px \"${customFont}\", serif`;\n            ctx.fillStyle = theme.colors.title;\n            ctx.fillText(item.content, padding, currentY);\n          currentY += headingSize + 15;\n          \n            // 在标题下绘制装饰线\n          if (item.level <= 2) {\n              const lineWidth = Math.min(ctx.measureText(item.content).width, contentWidth * 0.6);\n              ctx.strokeStyle = theme.colors.decorativeLine;\n              ctx.lineWidth = item.level === 1 ? 2 : 1;\n              ctx.beginPath();\n              ctx.moveTo(padding, currentY - 10);\n              ctx.lineTo(padding + lineWidth, currentY - 10);\n              ctx.stroke();\n            currentY += 10;\n          }\n          break;\n          \n        case 'table':\n            const tableHeight = drawTable(ctx, item, padding, currentY, contentWidth, theme, customFont);\n            currentY += tableHeight + 20;\n          break;\n          \n        case 'list':\n          ctx.font = `14px \"${customFont}\", serif`;\n            ctx.fillStyle = theme.colors.notes;\n            const listX = padding + item.indent + 20;\n            const bullet = item.numbered ? item.marker : (item.marker || '◦');\n            ctx.textAlign = 'left';\n            ctx.fillText(bullet, listX - 15, currentY);\n            \n            // 换行处理列表内容\n          const listLines = wrapText(ctx, item.content, contentWidth - item.indent - 30);\n            listLines.forEach((line, index) => {\n              ctx.fillText(line, listX, currentY);\n              currentY += 20;\n            });\n          break;\n          \n        case 'quote':\n            // 绘制引用块\n            ctx.fillStyle = theme.colors.accent + '20';\n            const quoteHeight = 25;\n            ctx.fillRect(padding - 5, currentY - 15, 5, quoteHeight);\n            \n          ctx.font = `italic 14px \"${customFont}\", serif`;\n            ctx.fillStyle = theme.colors.excerpt;\n          const quoteLines = wrapText(ctx, item.content, contentWidth - 20);\n            quoteLines.forEach(line => {\n              ctx.fillText(line, padding + 15, currentY);\n              currentY += 22;\n            });\n          break;\n          \n        case 'code':\n            // 绘制代码块\n            ctx.fillStyle = theme.colors.separatorLine + '30';\n            const codeHeight = 22;\n            ctx.fillRect(padding, currentY - 15, contentWidth, codeHeight);\n            \n            ctx.font = `13px \"Courier New\", monospace`;\n            ctx.fillStyle = theme.colors.notes;\n            ctx.fillText(item.content, padding + 10, currentY);\n          currentY += 25;\n          break;\n          \n        case 'empty':\n            currentY += 15; // 空行间距\n          break;\n          \n        case 'paragraph':\n        default:\n      ctx.font = `16px \"${customFont}\", serif`;\n      ctx.fillStyle = theme.colors.notes;\n            \n          const paragraphLines = wrapText(ctx, item.content, contentWidth);\n            paragraphLines.forEach(line => {\n          ctx.fillText(line, padding, currentY);\n              currentY += 24;\n            });\n            currentY += 8; // 段落间距\n          break;\n        }\n      });\n\n      // 底部标语\n      currentY += 20;\n      ctx.font = `14px \"${customFont}\", serif`;\n      ctx.fillStyle = theme.colors.brand;\n      ctx.textAlign = 'center';\n      ctx.fillText('- 来自酒馆Memo -', width / 2, currentY + 20);\n\n      resolve();\n    });\n  }\n  // 渲染LLM设置界面\n  function renderLLMSettings() {\n    // 设置当前视图状态\n    state.currentView = 'llm-settings';\n  \n    // 确保加载最新配置\n    loadLLMConfig();\n  \n    modalTitleElement.textContent = 'LLM设置';\n  \n    const html = `\n      <div class=\"memo-form\">\n        <div style=\"margin-bottom: 12px; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7)); font-size: 14px; line-height: 1.4;\">\n          配置LLM API以生成使用报告。部分gemini反代不支持。\n        </div>\n        \n        <div class=\"memo-form-group\">\n          <label class=\"memo-form-label\" for=\"llmApiUrl\">基础URL：</label>\n          <input type=\"text\" id=\"llmApiUrl\" \n                 placeholder=\"输入你的API地址\" \n                 value=\"${escapeHtml(state.llmConfig.apiUrl)}\"\n                 style=\"padding: 12px 16px;\n                        border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                        border-radius: 10px;\n                        background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n                        color: var(--SmartThemeBodyColor, #ffffff);\n                        font-size: 14px;\n                        transition: all 0.3s ease;\n                        font-weight: 500;\n                        width: 100%;\n                        box-sizing: border-box;\" />\n        </div>\n        \n        <div class=\"memo-form-group\">\n          <label class=\"memo-form-label\" for=\"llmApiKey\">API密钥：</label>\n          <input type=\"password\" id=\"llmApiKey\" \n                 placeholder=\"输入您的API密钥\" \n                 value=\"${escapeHtml(state.llmConfig.apiKey)}\"\n                 style=\"padding: 12px 16px;\n                        border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                        border-radius: 10px;\n                        background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n                        color: var(--SmartThemeBodyColor, #ffffff);\n                        font-size: 14px;\n                        transition: all 0.3s ease;\n                        font-weight: 500;\n                        width: 100%;\n                        box-sizing: border-box;\" />\n        </div>\n        \n        <div style=\"display: flex; gap: 15px; margin-bottom: 15px;\">\n          <button id=\"fetchModelsBtn\" class=\"memo-button secondary\" style=\"flex: 1;\">\n            获取模型列表\n          </button>\n          <button id=\"testConnectionBtn\" class=\"memo-button secondary\" style=\"flex: 1;\">\n            测试连接\n          </button>\n        </div>\n        \n        <div class=\"memo-form-group\">\n          <label class=\"memo-form-label\" for=\"llmModel\">选择模型：</label>\n          <select id=\"llmModel\" \n                  style=\"padding: 12px 16px;\n                         border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                         border-radius: 10px;\n                         background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n                         color: var(--SmartThemeBodyColor, #ffffff);\n                         font-size: 14px;\n                         transition: all 0.3s ease;\n                         font-weight: 500;\n                         width: 100%;\n                         box-sizing: border-box;\">\n            <option value=\"\">请先获取模型列表</option>\n            ${state.llmConfig.availableModels.map(model => `\n              <option value=\"${model}\" ${model === state.llmConfig.model ? 'selected' : ''}>\n                ${model}\n              </option>\n            `).join('')}\n          </select>\n        </div>\n        \n        <div class=\"memo-form-group\">\n          <label class=\"memo-form-label\" for=\"llmTemperature\">温度参数 (0-1)：</label>\n          <input type=\"number\" id=\"llmTemperature\" \n                 min=\"0\" max=\"1\" step=\"0.1\"\n                 placeholder=\"0.7\" \n                 value=\"${state.llmConfig.temperature}\"\n                 style=\"padding: 12px 16px;\n                        border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                        border-radius: 10px;\n                        background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n                        color: var(--SmartThemeBodyColor, #ffffff);\n                        font-size: 14px;\n                        transition: all 0.3s ease;\n                        font-weight: 500;\n                        width: 100%;\n                        box-sizing: border-box;\" />\n          <div style=\"margin-top: 5px; font-size: 12px; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.5));\">\n            较高的值会让输出更随机，较低的值会让输出更确定\n          </div>\n        </div>\n        \n        <div id=\"llmTestStatus\" style=\"\n          margin-top: 12px;\n          padding: 10px;\n          border-radius: 8px;\n          background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n          color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7));\n          font-size: 12px;\n          text-align: center;\n          display: none;\n        \">状态显示区域</div>\n      </div>\n    `;\n  \n    modalBodyElement.innerHTML = html;\n  \n    // 绑定输入框样式\n    ['llmApiUrl', 'llmApiKey', 'llmModel', 'llmTemperature'].forEach(id => {\n      const input = MemoDoc.getElementById(id);\n      if (input) {\n        input.addEventListener('focus', function () {\n          this.style.borderColor = 'var(--SmartThemeQuoteColor, #4a9eff)';\n          this.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.08))';\n          this.style.boxShadow = '0 0 0 3px var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2))';\n        });\n        input.addEventListener('blur', function () {\n          this.style.borderColor = 'var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1))';\n          this.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05))';\n          this.style.boxShadow = 'none';\n        });\n      }\n    });\n  \n    // 绑定按钮事件\n    const fetchModelsBtn = MemoDoc.getElementById('fetchModelsBtn');\n    const testConnectionBtn = MemoDoc.getElementById('testConnectionBtn');\n    const statusElem = MemoDoc.getElementById('llmTestStatus');\n  \n    if (fetchModelsBtn) {\n      fetchModelsBtn.addEventListener('click', async () => {\n        let apiUrl = MemoDoc.getElementById('llmApiUrl').value.trim();\n        const apiKey = MemoDoc.getElementById('llmApiKey').value.trim();\n        \n        if (!apiUrl || !apiKey) {\n          toastr.error('请先填写API地址和密钥');\n          return;\n        }\n\n        // 自动添加 /chat/completions\n        apiUrl = apiUrl + '/chat/completions';\n  \n        fetchModelsBtn.disabled = true;\n        fetchModelsBtn.textContent = '获取中...';\n        statusElem.style.display = 'block';\n        statusElem.textContent = '正在获取模型列表...';\n  \n        try {\n          const models = await fetchAvailableModels(apiUrl, apiKey);\n          state.llmConfig.availableModels = models;\n          \n          // 更新模型选择器\n          const modelSelect = MemoDoc.getElementById('llmModel');\n          modelSelect.innerHTML = models.map(model => `\n            <option value=\"${model}\">${model}</option>\n          `).join('');\n          \n          statusElem.textContent = `✅ 成功获取到 ${models.length} 个模型`;\n          statusElem.style.color = 'var(--SmartThemeQuoteColor, #4a9eff)';\n          toastr.success(`获取到 ${models.length} 个可用模型`);\n        } catch (error) {\n          statusElem.textContent = `❌ 获取模型列表失败: ${error.message}`;\n          statusElem.style.color = '#ff4757';\n          toastr.error('获取模型列表失败');\n        } finally {\n          fetchModelsBtn.disabled = false;\n          fetchModelsBtn.textContent = '获取模型列表';\n        }\n      });\n    }\n  \n    if (testConnectionBtn) {\n      testConnectionBtn.addEventListener('click', async () => {\n        let apiUrl = MemoDoc.getElementById('llmApiUrl').value.trim();\n        const apiKey = MemoDoc.getElementById('llmApiKey').value.trim();\n        \n        if (!apiUrl || !apiKey) {\n          toastr.error('请先填写API地址和密钥');\n          return;\n        }\n\n        // 自动添加 /chat/completions\n        apiUrl = apiUrl + '/chat/completions';\n  \n        testConnectionBtn.disabled = true;\n        testConnectionBtn.textContent = '测试中...';\n        statusElem.style.display = 'block';\n        statusElem.textContent = '正在测试连接...';\n  \n        try {\n          const result = await testLLMConnection(apiUrl, apiKey);\n          if (result.success) {\n            statusElem.textContent = '✅ 连接测试成功！';\n            statusElem.style.color = 'var(--SmartThemeQuoteColor, #4a9eff)';\n            toastr.success('LLM连接测试成功！');\n          } else {\n            statusElem.textContent = `❌ 连接测试失败: ${result.error}`;\n            statusElem.style.color = '#ff4757';\n            toastr.error('连接测试失败');\n          }\n        } catch (error) {\n          statusElem.textContent = `❌ 测试出错: ${error.message}`;\n          statusElem.style.color = '#ff4757';\n          toastr.error('连接测试失败');\n        } finally {\n          testConnectionBtn.disabled = false;\n          testConnectionBtn.textContent = '测试连接';\n        }\n      });\n    }\n  \n    // 渲染底部按钮\n    modalFooterElement.innerHTML = '';\n    modalFooterElement.appendChild(createButton('保存设置', 'primary', saveLLMSettingsAndReturn));\n    modalFooterElement.appendChild(createButton('返回', 'secondary', () => renderYearlyReportGenerator()));\n  \n    // 重新居中模态框\n    requestAnimationFrame(() => {\n      centerModal();\n    });\n  }\n  \n  // 保存LLM设置并返回列表\n  function saveLLMSettingsAndReturn() {\n    let apiUrl = MemoDoc.getElementById('llmApiUrl')?.value?.trim() || '';\n    const apiKey = MemoDoc.getElementById('llmApiKey')?.value?.trim() || '';\n    const model = MemoDoc.getElementById('llmModel')?.value?.trim() || '';\n    const temperature = parseFloat(MemoDoc.getElementById('llmTemperature')?.value) || 0.7;\n\n    // 自动添加 /chat/completions\n    if (apiUrl) {\n      apiUrl = apiUrl + '/chat/completions';\n    }\n\n    // 更新配置\n    const config = {\n      apiUrl,\n      apiKey,\n      model,\n      temperature\n    };\n\n    if (saveLLMConfig(config)) {\n      toastr.success('LLM设置已保存');\n      // 保存后停留在LLM设置界面\n      renderLLMSettings();\n    } else {\n      toastr.error('保存设置失败');\n    }\n  }\n  \n  // 渲染使用报告生成界面\n  function renderYearlyReportGenerator() {\n    // 设置当前视图状态\n    state.currentView = 'yearly-report';\n  \n    modalTitleElement.textContent = '生成使用报告';\n  \n    // 获取所有聊天的memo数据\n    const allChats = getAllMemoChats();\n  \n    const html = `\n      <div class=\"memo-form\">\n        <div style=\"margin-bottom: 10px; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7)); font-size: 14px; line-height: 1.5;\">\n          选择要包含在使用报告中的对话记录，系统将基于这些Memo生成您的使用报告。\n        </div>\n        \n        <div class=\"memo-form-group\">\n          <label class=\"memo-form-label\">选择对话记录：</label>\n          <div style=\"max-height: 300px; overflow-y: auto; border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1)); border-radius: 8px; padding: 10px;\">\n            ${allChats.length === 0 ? `\n              <div style=\"text-align: center; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.5)); padding: 20px;\">\n                暂无Memo记录\n              </div>\n            ` : allChats.map(chat => `\n              <div style=\"display: flex; align-items: center; margin-bottom: 8px; padding: 8px; border-radius: 6px; background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\">\n                <input type=\"checkbox\" id=\"chat_${chat.context}\" class=\"chat-checkbox\" \n                       style=\"margin-right: 10px; transform: scale(1.2);\" />\n                <label for=\"chat_${chat.context}\" style=\"flex: 1; cursor: pointer; color: var(--SmartThemeBodyColor, #ffffff);\">\n                  ${escapeHtml(chat.name)} (${chat.count} 条memo)\n                </label>\n              </div>\n            `).join('')}\n          </div>\n        </div>\n        \n        <div style=\"display: flex; justify-content: center; margin-top: 15px;\">\n          <button id=\"toggleSelectAllChats\" class=\"memo-button secondary\" style=\"min-width: 120px;\">\n            全选\n          </button>\n        </div>\n        \n        <div id=\"reportGenerationStatus\" style=\"\n          margin-top: 15px;\n          padding: 10px;\n          border-radius: 8px;\n          background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n          color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7));\n          font-size: 12px;\n          text-align: center;\n          display: none;\n        \">生成状态显示区域</div>\n      </div>\n    `;\n  \n    modalBodyElement.innerHTML = html;\n  \n    // 绑定事件\n    const toggleSelectBtn = MemoDoc.getElementById('toggleSelectAllChats');\n    const checkboxes = modalBodyElement.querySelectorAll('.chat-checkbox');\n    \n    // 检查当前选择状态的函数\n    const updateToggleButton = () => {\n      const checkedCount = modalBodyElement.querySelectorAll('.chat-checkbox:checked').length;\n      const totalCount = checkboxes.length;\n      \n      if (checkedCount === totalCount && totalCount > 0) {\n        // 全选状态\n        toggleSelectBtn.textContent = '清空';\n        toggleSelectBtn.classList.remove('secondary');\n        toggleSelectBtn.classList.add('danger');\n      } else {\n        // 未全选状态\n        toggleSelectBtn.textContent = '全选';\n        toggleSelectBtn.classList.remove('danger');\n        toggleSelectBtn.classList.add('secondary');\n      }\n    };\n    \n    // 切换全选/清空的函数\n    const toggleSelectAll = () => {\n      const checkedCount = modalBodyElement.querySelectorAll('.chat-checkbox:checked').length;\n      const totalCount = checkboxes.length;\n      \n      if (checkedCount === totalCount && totalCount > 0) {\n        // 当前是全选状态，执行清空\n        checkboxes.forEach(checkbox => checkbox.checked = false);\n      } else {\n        // 当前不是全选状态，执行全选\n        checkboxes.forEach(checkbox => checkbox.checked = true);\n      }\n      \n      updateToggleButton();\n    };\n  \n    if (toggleSelectBtn) {\n      toggleSelectBtn.addEventListener('click', toggleSelectAll);\n    }\n    \n    // 监听单个复选框变化，更新按钮状态\n    checkboxes.forEach(checkbox => {\n      checkbox.addEventListener('change', updateToggleButton);\n    });\n    \n    // 初始化按钮状态\n    updateToggleButton();\n  \n    // 渲染底部按钮\n    modalFooterElement.innerHTML = '';\n    modalFooterElement.appendChild(createButton('生成报告', 'primary', generateReportFromSelection));\n    modalFooterElement.appendChild(createButton('LLM设置', 'secondary', () => renderLLMSettings()));\n    modalFooterElement.appendChild(createButton('返回', 'secondary', () => renderMemoList()));\n  \n    // 重新居中模态框\n    requestAnimationFrame(() => {\n      centerModal();\n    });\n  }\n  \n  // 从选择的对话生成报告\n  async function generateReportFromSelection() {\n    const checkboxes = modalBodyElement.querySelectorAll('.chat-checkbox:checked');\n    const statusElem = MemoDoc.getElementById('reportGenerationStatus');\n    \n    if (checkboxes.length === 0) {\n      toastr.error('请至少选择一个对话记录');\n      return;\n    }\n  \n    // 检查LLM配置\n    if (!state.llmConfig.apiUrl || !state.llmConfig.apiKey || !state.llmConfig.model) {\n      toastr.error('请先完成LLM设置');\n      renderLLMSettings();\n      return;\n    }\n  \n    try {\n      statusElem.style.display = 'block';\n      statusElem.textContent = '正在收集Memo数据...';\n  \n      // 收集选中的memo数据\n      const selectedMemos = [];\n      checkboxes.forEach(checkbox => {\n        const context = checkbox.id.replace('chat_', '');\n        const memos = loadMemosFromStorage(context);\n        selectedMemos.push(...memos);\n      });\n  \n      if (selectedMemos.length === 0) {\n        toastr.error('选中的对话没有Memo记录');\n        return;\n      }\n  \n      // 生成报告\n      const reportText = await generateYearlyReport(selectedMemos, (status) => {\n        statusElem.textContent = status;\n      });\n  \n      statusElem.textContent = '正在生成长图...';\n  \n      // 生成长图\n      const imageDataUrl = await generateYearlyReportImage(reportText);\n  \n      // 显示结果\n      showYearlyReportResult(reportText, imageDataUrl);\n  \n    } catch (error) {\n      console.error('生成使用报告失败:', error);\n      statusElem.textContent = `❌ 生成失败: ${error.message}`;\n      statusElem.style.color = '#ff4757';\n      toastr.error('生成使用报告失败: ' + error.message);\n    }\n  }\n  \n  // 显示使用报告结果\n  function showYearlyReportResult(reportText, imageDataUrl) {\n    state.currentView = 'yearly-report-result';\n  \n    // 保存当前报告文本和图片数据\n    state.currentReportText = reportText;\n    state.currentReportImageUrl = imageDataUrl;\n  \n    // 加载当前样式和字体配置\n    const currentStyle = loadStylePreference();\n    const currentFont = loadFontPreference();\n\n    // 创建字体选项列表 - 包含默认字体和已加载的网络字体\n    const fontOptions = [\n      { value: 'QiushuiShotai', name: '秋水正楷', description: '默认' }\n    ];\n    \n    // 添加已加载的网络字体\n    for (const fontName of state.fontConfig.loadedFonts) {\n      if (fontName !== 'QiushuiShotai') {\n        fontOptions.push({\n          value: fontName,\n          name: fontName,\n          description: '网络字体'\n        });\n      }\n    }\n\n    modalTitleElement.textContent = '使用报告';\n\n    const html = `\n      <div style=\"display: flex; flex-direction: column; gap: 20px;\">\n        <!-- 文本编辑区域 -->\n        <div class=\"memo-form-group\">\n          <label class=\"memo-form-label\">编辑报告内容：</label>\n          <textarea id=\"reportTextEditor\" \n                    style=\"width: 100%; \n                           height: 200px; \n                           padding: 12px; \n                           border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1)); \n                           border-radius: 8px; \n                           background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05)); \n                           color: var(--SmartThemeBodyColor, #ffffff); \n                           font-family: inherit; \n                           font-size: 14px; \n                           line-height: 1.6; \n                           resize: vertical; \n                           box-sizing: border-box;\"\n                    placeholder=\"在这里编辑您的使用报告内容...\">${escapeHtml(reportText)}</textarea>\n        </div>\n        \n        <!-- 样式和字体选择器 -->\n        <div style=\"margin-bottom: 20px; display: flex; flex-direction: column; gap: 16px;\">\n          <!-- 样式选择器行 -->\n          <div style=\"display: flex; align-items: center; gap: 12px; flex-wrap: wrap;\">\n            <label style=\"color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8)); font-size: 14px; font-weight: 500; min-width: 80px;\">\n              卡片样式：\n            </label>\n            <select id=\"reportStyleSelector\" style=\"\n              padding: 8px 12px;\n              border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n              border-radius: 8px;\n              background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n              color: var(--SmartThemeBodyColor, #ffffff);\n              font-size: 14px;\n              cursor: pointer;\n              transition: all 0.3s ease;\n              min-width: 160px;\n              appearance: none;\n              -webkit-appearance: none;\n              -moz-appearance: none;\n              background-image: url(\\\"data:image/svg+xml;charset=UTF-8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6,9 12,15 18,9'></polyline></svg>\\\");\n              background-repeat: no-repeat;\n              background-position: right 8px center;\n              background-size: 16px;\n              padding-right: 32px;\n            \">\n              <option value=\"summer\" ${currentStyle === 'summer' ? 'selected' : ''}>长夏 - 绿色</option>\n              <option value=\"marshmallow\" ${currentStyle === 'marshmallow' ? 'selected' : ''}>棉花糖 - 粉蓝</option>\n              <option value=\"drowninlove\" ${currentStyle === 'drowninlove' ? 'selected' : ''}>泥沼中 - 青黑</option> \n              <option value=\"papper\" ${currentStyle === 'papper' ? 'selected' : ''}>如是说 - 信纸</option>\n              <option value=\"rose\" ${currentStyle === 'rose' ? 'selected' : ''}>朱砂痣 - 朱红</option>\n              <option value=\"ink\" ${currentStyle === 'ink' ? 'selected' : ''}>缓缓 - 淡墨</option>\n              <option value=\"custom\" ${currentStyle === 'custom' ? 'selected' : ''}>自定义配色</option>\n            </select>\n          </div>\n          \n          <!-- 字体选择器行 -->\n          <div style=\"display: flex; align-items: center; gap: 12px; flex-wrap: wrap;\">\n            <label style=\"color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8)); font-size: 14px; font-weight: 500; min-width: 80px;\">\n              字体选择：\n            </label>\n            <select id=\"reportFontSelector\" style=\"\n              padding: 8px 12px;\n              border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n              border-radius: 8px;\n              background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n              color: var(--SmartThemeBodyColor, #ffffff);\n              font-size: 14px;\n              cursor: pointer;\n              transition: all 0.3s ease;\n              min-width: 160px;\n              appearance: none;\n              -webkit-appearance: none;\n              -moz-appearance: none;\n              background-image: url(\\\"data:image/svg+xml;charset=UTF-8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23ffffff' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'><polyline points='6,9 12,15 18,9'></polyline></svg>\\\");\n              background-repeat: no-repeat;\n              background-position: right 8px center;\n              background-size: 16px;\n              padding-right: 32px;\n            \">\n              ${fontOptions.map(option => `\n                <option value=\"${option.value}\" ${option.value === currentFont ? 'selected' : ''}>\n                  ${option.name} - ${option.description}\n                </option>\n              `).join('')}\n            </select>\n          </div>\n          \n          <!-- CSS字体URL输入行 -->\n          <div class=\"memo-form-group\">\n            <label class=\"memo-form-label\">加载网络字体：</label>\n            <div style=\"display: flex; align-items: center; gap: 12px; flex-wrap: wrap;\">\n              <input type=\"text\" id=\"reportFontUrlInput\" placeholder=\"输入CSS字体URL或@import链接...\" style=\"\n                flex: 1;\n                min-width: 300px;\n                padding: 8px 12px;\n                border: 2px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                border-radius: 6px;\n                background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n                color: var(--SmartThemeBodyColor, #ffffff);\n                font-size: 14px;\n                transition: all 0.3s ease;\n              \" />\n              \n              <button id=\"reportLoadFontBtn\" style=\"\n                padding: 8px 16px;\n                background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.7));\n                color: var(--SmartThemeBodyColor, #ffffff);\n                border: 1px solid var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.4));\n                border-radius: 6px;\n                cursor: pointer;\n                font-size: 14px;\n                font-weight: 500;\n                transition: all 0.2s ease;\n                box-shadow: 0 2px 8px rgba(74, 158, 255, 0.15);\n                white-space: nowrap;\n              \">\n                <i class=\"fas fa-link\" style=\"margin-right: 6px; font-size: 12px;\"></i>\n                加载字体\n              </button>\n            </div>\n          </div>\n          \n          <!-- 重新生成按钮 -->\n          <div style=\"display: flex; justify-content: center; margin-top: 8px;\">\n            <button id=\"regenerateImageBtn\" class=\"memo-button secondary\" style=\"min-width: 140px;\">\n              重新生成报告\n            </button>\n          </div>\n          \n          <!-- 自定义配色配置区域 -->\n          <div id=\"customColorConfigContainer\" style=\"\n            display: none;\n            margin-top: 16px;\n            padding: 16px;\n            border: 2px solid var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2));\n            border-radius: 8px;\n            background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n          \">\n            <h4 style=\"margin: 0 0 12px 0; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.9)); font-size: 14px;\">\n              自定义配色设置\n            </h4>\n            \n            <div style=\"display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;\">\n              <div>\n                <label style=\"display: block; margin-bottom: 4px; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8)); font-size: 12px;\">\n                  背景色1（左上）\n                </label>\n                <input type=\"color\" id=\"reportCustomColor1\" value=\"${state.customColorConfig.color1}\" style=\"\n                  width: 100%;\n                  height: 36px;\n                  border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                  border-radius: 4px;\n                  background: transparent;\n                  cursor: pointer;\n                \" />\n              </div>\n              <div>\n                <label style=\"display: block; margin-bottom: 4px; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8)); font-size: 12px;\">\n                  背景色2（右下）\n                </label>\n                <input type=\"color\" id=\"reportCustomColor2\" value=\"${state.customColorConfig.color2}\" style=\"\n                  width: 100%;\n                  height: 36px;\n                  border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                  border-radius: 4px;\n                  background: transparent;\n                  cursor: pointer;\n                \" />\n              </div>\n            </div>\n            \n            <div>\n              <label style=\"display: block; margin-bottom: 4px; color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.8)); font-size: 12px;\">\n                字体颜色\n              </label>\n              <input type=\"color\" id=\"reportCustomFontColor\" value=\"${state.customColorConfig.fontColor}\" style=\"\n                width: 100%;\n                height: 36px;\n                border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1));\n                border-radius: 4px;\n                background: transparent;\n                cursor: pointer;\n              \" />\n            </div>\n            \n            <div style=\"margin-top: 12px; text-align: center;\">\n              <button id=\"reportApplyCustomColorsBtn\" style=\"\n                padding: 6px 16px;\n                background: var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.7));\n                color: var(--SmartThemeBodyColor, #ffffff);\n                border: 1px solid var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.4));\n                border-radius: 4px;\n                cursor: pointer;\n                font-size: 12px;\n                font-weight: 500;\n              \">\n                应用配色\n              </button>\n            </div>\n          </div>\n        </div>\n        \n        <!-- 生成状态显示 -->\n        <div id=\"imageGenerationStatus\" style=\"\n          padding: 10px;\n          border-radius: 8px;\n          background: var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05));\n          color: var(--SmartThemeBodyColor, rgba(255, 255, 255, 0.7));\n          font-size: 12px;\n          text-align: center;\n          display: none;\n        \">正在生成长图...</div>\n        \n        <!-- 长图预览区域 -->\n        <div style=\"text-align: center;\">\n          <div style=\"max-height: 400px; \n                      overflow: auto; \n                      border: 1px solid var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1)); \n                      border-radius: 8px; \n                      background: #fff; \n                      padding: 10px;\">\n            <img id=\"reportImagePreview\" \n                 src=\"${imageDataUrl}\" \n                 style=\"max-width: 100%; height: auto; border-radius: 4px;\" \n                 alt=\"使用报告长图\" />\n          </div>\n        </div>\n      </div>\n    `;\n\n    modalBodyElement.innerHTML = html;\n    \n    // 绑定事件\n    const textEditor = MemoDoc.getElementById('reportTextEditor');\n    const styleSelector = MemoDoc.getElementById('reportStyleSelector');\n    const fontSelector = MemoDoc.getElementById('reportFontSelector');\n    const regenerateBtn = MemoDoc.getElementById('regenerateImageBtn');\n    const statusElem = MemoDoc.getElementById('imageGenerationStatus');\n    const imagePreview = MemoDoc.getElementById('reportImagePreview');\n    \n    // CSS字体URL输入框和加载按钮\n    const fontUrlInput = MemoDoc.getElementById('reportFontUrlInput');\n    const loadFontBtn = MemoDoc.getElementById('reportLoadFontBtn');\n    \n    // 重新生成报告函数\n    const regenerateImage = async () => {\n      try {\n        const newText = textEditor.value.trim();\n        const selectedStyle = styleSelector.value;\n        const selectedFont = fontSelector.value;\n        \n        if (!newText) {\n          toastr.error('报告内容不能为空');\n          return;\n        }\n        \n        regenerateBtn.disabled = true;\n        regenerateBtn.textContent = '生成中...';\n        statusElem.style.display = 'block';\n        statusElem.textContent = '正在生成长图...';\n        \n        // 生成新的长图\n        const newImageDataUrl = await generateYearlyReportImage(newText, selectedStyle, selectedFont);\n        \n        // 更新预览图片\n        imagePreview.src = newImageDataUrl;\n        \n        // 更新状态\n        state.currentReportText = newText;\n        state.currentReportImageUrl = newImageDataUrl;\n        \n        // 保存样式和字体偏好\n        saveStylePreference(selectedStyle);\n        saveFontPreference(selectedFont);\n        \n        statusElem.textContent = '✅ 长图生成成功！';\n        statusElem.style.color = 'var(--SmartThemeQuoteColor, #4a9eff)';\n        \n        setTimeout(() => {\n          statusElem.style.display = 'none';\n        }, 2000);\n        \n        toastr.success('长图已更新！');\n        \n      } catch (error) {\n        console.error('重新生成报告失败:', error);\n        statusElem.textContent = `❌ 生成失败: ${error.message}`;\n        statusElem.style.color = '#ff4757';\n        toastr.error('生成长图失败: ' + error.message);\n      } finally {\n        regenerateBtn.disabled = false;\n        regenerateBtn.textContent = '重新生成报告';\n      }\n    };\n    \n    // 绑定重新生成按钮事件\n    if (regenerateBtn) {\n      regenerateBtn.addEventListener('click', regenerateImage);\n    }\n    \n    // 绑定字体加载按钮事件（复用分享卡片中的字体管理函数）\n    if (loadFontBtn && fontUrlInput) {\n      loadFontBtn.addEventListener('click', () => {\n        const fontUrl = fontUrlInput.value.trim();\n        if (fontUrl) {\n          // 使用现有的字体加载函数\n          loadFontFromUrl(fontUrl, fontSelector);\n        } else {\n          toastr.warning('请输入字体URL或@import链接');\n        }\n      });\n      \n      // 支持回车键加载\n      fontUrlInput.addEventListener('keypress', (e) => {\n        if (e.key === 'Enter') {\n          const fontUrl = fontUrlInput.value.trim();\n          if (fontUrl) {\n            loadFontFromUrl(fontUrl, fontSelector);\n          }\n        }\n      });\n    }\n    \n    // 绑定输入框样式\n    const inputElements = [textEditor, fontUrlInput];\n    inputElements.forEach(element => {\n      if (element) {\n        element.addEventListener('focus', function () {\n          this.style.borderColor = 'var(--SmartThemeQuoteColor, #4a9eff)';\n          this.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.08))';\n          this.style.boxShadow = '0 0 0 3px var(--SmartThemeQuoteColor, rgba(74, 158, 255, 0.2))';\n        });\n        element.addEventListener('blur', function () {\n          this.style.borderColor = 'var(--SmartThemeBorderColor, rgba(255, 255, 255, 0.1))';\n          this.style.background = 'var(--SmartThemeBlurTintColor, rgba(255, 255, 255, 0.05))';\n          this.style.boxShadow = 'none';\n        });\n      }\n    });\n\n    // 为选择器添加焦点样式\n    addSelectFocusStyles('#reportStyleSelector');\n    addSelectFocusStyles('#reportFontSelector');\n\n    // 渲染底部按钮\n    modalFooterElement.innerHTML = '';\n    modalFooterElement.appendChild(createButton('下载长图', 'primary', () => downloadYearlyReportImage(state.currentReportImageUrl)));\n    modalFooterElement.appendChild(createButton('重新生成报告', 'secondary', () => renderYearlyReportGenerator()));\n    modalFooterElement.appendChild(createButton('返回列表', 'secondary', () => renderMemoList()));\n\n    // 重新居中模态框\n    requestAnimationFrame(() => {\n      centerModal();\n    });\n\n    // 样式选择器事件 - 添加自定义配色展开功能\n    styleSelector.addEventListener('change', (e) => {\n      const newStyle = e.target.value;\n      \n      // 显示或隐藏自定义配色配置\n      const customColorContainer = MemoDoc.getElementById('customColorConfigContainer');\n      if (customColorContainer) {\n        if (newStyle === 'custom') {\n          customColorContainer.style.display = 'block';\n        } else {\n          customColorContainer.style.display = 'none';\n        }\n      }\n    });\n\n    // 自定义配色相关事件\n    const customColorContainer = MemoDoc.getElementById('customColorConfigContainer');\n    const reportCustomColor1 = MemoDoc.getElementById('reportCustomColor1');\n    const reportCustomColor2 = MemoDoc.getElementById('reportCustomColor2');\n    const reportCustomFontColor = MemoDoc.getElementById('reportCustomFontColor');\n    const reportApplyCustomColorsBtn = MemoDoc.getElementById('reportApplyCustomColorsBtn');\n\n    // 初始化自定义配色显示状态\n    if (customColorContainer && styleSelector.value === 'custom') {\n      customColorContainer.style.display = 'block';\n    }\n\n    // 应用自定义配色按钮事件\n    if (reportApplyCustomColorsBtn && reportCustomColor1 && reportCustomColor2 && reportCustomFontColor) {\n      reportApplyCustomColorsBtn.addEventListener('click', () => {\n        // 更新自定义配色配置\n        state.customColorConfig.color1 = reportCustomColor1.value;\n        state.customColorConfig.color2 = reportCustomColor2.value;\n        state.customColorConfig.fontColor = reportCustomFontColor.value;\n        \n        // 保存配置\n        saveCustomColorConfig(state.customColorConfig);\n        \n        // 如果当前选择的是自定义配色，重新生成图片\n        if (styleSelector.value === 'custom') {\n          regenerateImage();\n        }\n        \n        toastr.success('自定义配色已应用！');\n      });\n    }\n  }\n  \n  // 下载使用报告长图\n  function downloadYearlyReportImage(imageDataUrl) {\n    try {\n      const timestamp = new Date().toISOString().slice(0, 16).replace(/[:\\-]/g, '');\n      const fileName = `memo_usage_report_${timestamp}.png`;\n  \n      const link = MemoDoc.createElement('a');\n      link.href = imageDataUrl;\n      link.download = fileName;\n  \n      MemoDoc.body.appendChild(link);\n      link.click();\n      MemoDoc.body.removeChild(link);\n  \n      toastr.success('使用报告长图已下载！');\n    } catch (error) {\n      console.error('下载使用报告长图失败:', error);\n      toastr.error('下载失败，请重试');\n    }\n  }\n",
  "info": "作者: 镜＆claude\n版本: 0.8.6\n功能简介: \n一个写memo、分享memo的小功能\n会按照角色-聊天名存储，可以切换聊天名来查看其他memo\n背景用的是酒馆的聊天背景色，按钮用的是引用字体色，可以自己改\n支持云同步存档，具体使用方法看原帖\n支持分享卡片自定义，字体请自行去找可用字体（https://fonts.zeoseven.com/）\n支持根据Memo生成用户行为总结报告（需要改提示词请看原贴）",
  "buttons": [
    {
      "name": "显示Memo",
      "visible": true
    }
  ],
  "data": {}
}